// Generated from Apache PDFBox library which is licensed under the Apache License 2.0.
// The following copyright from the original authors applies.
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;

import "package:jni/jni.dart" as jni;

import "../../../init.dart" show jlookup;

/// from: org.apache.pdfbox.pdmodel.PDDocument
///
/// This is the in-memory representation of the PDF document.
/// The \#close() method must be called once the document is no longer needed.
///@author Ben Litchfield
class PDDocument extends jni.JlObject {
  PDDocument.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_RESERVE_BYTE_RANGE =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_org_apache_pdfbox_pdmodel_PDDocument_RESERVE_BYTE_RANGE")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: private static final int[] RESERVE_BYTE_RANGE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For signing: large reserve byte range used as placeholder in the saved PDF until the actual
  /// length of the PDF is known. You'll need to fetch (with
  /// PDSignature\#getByteRange() ) and reassign this yourself (with
  /// PDSignature\#setByteRange(int[]) ) only if you call
  /// \#saveIncrementalForExternalSigning(java.io.OutputStream) saveIncrementalForExternalSigning()
  /// twice.
  static jni.JlObject get RESERVE_BYTE_RANGE =>
      jni.JlObject.fromRef(_get_RESERVE_BYTE_RANGE());

  static final _get_LOG =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_org_apache_pdfbox_pdmodel_PDDocument_LOG")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: private static final org.apache.commons.logging.Log LOG
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JlObject get LOG => jni.JlObject.fromRef(_get_LOG());

  static final _get_document = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_document")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private final org.apache.pdfbox.cos.COSDocument document
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get document => jni.JlObject.fromRef(_get_document(reference));

  static final _get_documentInformation = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_documentInformation")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private org.apache.pdfbox.pdmodel.PDDocumentInformation documentInformation
  /// The returned object must be deleted after use, by calling the `delete` method.
  PDDocumentInformation get documentInformation =>
      PDDocumentInformation.fromRef(_get_documentInformation(reference));
  static final _set_documentInformation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_pdmodel_PDDocument_documentInformation")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.PDDocumentInformation documentInformation
  /// The returned object must be deleted after use, by calling the `delete` method.
  set documentInformation(PDDocumentInformation value) =>
      _set_documentInformation(reference, value.reference);

  static final _get_documentCatalog = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_documentCatalog")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private org.apache.pdfbox.pdmodel.PDDocumentCatalog documentCatalog
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get documentCatalog =>
      jni.JlObject.fromRef(_get_documentCatalog(reference));
  static final _set_documentCatalog = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_pdmodel_PDDocument_documentCatalog")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.PDDocumentCatalog documentCatalog
  /// The returned object must be deleted after use, by calling the `delete` method.
  set documentCatalog(jni.JlObject value) =>
      _set_documentCatalog(reference, value.reference);

  static final _get_encryption = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_encryption")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private org.apache.pdfbox.pdmodel.encryption.PDEncryption encryption
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get encryption =>
      jni.JlObject.fromRef(_get_encryption(reference));
  static final _set_encryption = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_pdmodel_PDDocument_encryption")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.encryption.PDEncryption encryption
  /// The returned object must be deleted after use, by calling the `delete` method.
  set encryption(jni.JlObject value) =>
      _set_encryption(reference, value.reference);

  static final _get_allSecurityToBeRemoved = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_allSecurityToBeRemoved")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private boolean allSecurityToBeRemoved
  bool get allSecurityToBeRemoved =>
      _get_allSecurityToBeRemoved(reference) != 0;
  static final _set_allSecurityToBeRemoved = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_org_apache_pdfbox_pdmodel_PDDocument_allSecurityToBeRemoved")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private boolean allSecurityToBeRemoved
  set allSecurityToBeRemoved(bool value) =>
      _set_allSecurityToBeRemoved(reference, value ? 1 : 0);

  static final _get_documentId = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_documentId")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.lang.Long documentId
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get documentId =>
      jni.JlObject.fromRef(_get_documentId(reference));
  static final _set_documentId = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_pdmodel_PDDocument_documentId")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.Long documentId
  /// The returned object must be deleted after use, by calling the `delete` method.
  set documentId(jni.JlObject value) =>
      _set_documentId(reference, value.reference);

  static final _get_pdfSource = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_pdfSource")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private final org.apache.pdfbox.io.RandomAccessRead pdfSource
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get pdfSource => jni.JlObject.fromRef(_get_pdfSource(reference));

  static final _get_accessPermission = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_accessPermission")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private org.apache.pdfbox.pdmodel.encryption.AccessPermission accessPermission
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get accessPermission =>
      jni.JlObject.fromRef(_get_accessPermission(reference));
  static final _set_accessPermission = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_pdmodel_PDDocument_accessPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.encryption.AccessPermission accessPermission
  /// The returned object must be deleted after use, by calling the `delete` method.
  set accessPermission(jni.JlObject value) =>
      _set_accessPermission(reference, value.reference);

  static final _get_fontsToSubset = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_fontsToSubset")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private final java.util.Set<org.apache.pdfbox.pdmodel.font.PDFont> fontsToSubset
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get fontsToSubset =>
      jni.JlObject.fromRef(_get_fontsToSubset(reference));

  static final _get_fontsToClose = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_fontsToClose")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private final java.util.Set<org.apache.fontbox.ttf.TrueTypeFont> fontsToClose
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get fontsToClose =>
      jni.JlObject.fromRef(_get_fontsToClose(reference));

  static final _get_signInterface = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_signInterface")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface signInterface
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get signInterface =>
      jni.JlObject.fromRef(_get_signInterface(reference));
  static final _set_signInterface = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_pdmodel_PDDocument_signInterface")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface signInterface
  /// The returned object must be deleted after use, by calling the `delete` method.
  set signInterface(jni.JlObject value) =>
      _set_signInterface(reference, value.reference);

  static final _get_signingSupport = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_signingSupport")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.digitalsignature.SigningSupport signingSupport
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get signingSupport =>
      jni.JlObject.fromRef(_get_signingSupport(reference));
  static final _set_signingSupport = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_pdmodel_PDDocument_signingSupport")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.digitalsignature.SigningSupport signingSupport
  /// The returned object must be deleted after use, by calling the `delete` method.
  set signingSupport(jni.JlObject value) =>
      _set_signingSupport(reference, value.reference);

  static final _get_resourceCache = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_resourceCache")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private org.apache.pdfbox.pdmodel.ResourceCache resourceCache
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get resourceCache =>
      jni.JlObject.fromRef(_get_resourceCache(reference));
  static final _set_resourceCache = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_pdmodel_PDDocument_resourceCache")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.ResourceCache resourceCache
  /// The returned object must be deleted after use, by calling the `delete` method.
  set resourceCache(jni.JlObject value) =>
      _set_resourceCache(reference, value.reference);

  static final _get_signatureAdded = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocument_signatureAdded")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private boolean signatureAdded
  bool get signatureAdded => _get_signatureAdded(reference) != 0;
  static final _set_signatureAdded = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_org_apache_pdfbox_pdmodel_PDDocument_signatureAdded")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private boolean signatureAdded
  set signatureAdded(bool value) =>
      _set_signatureAdded(reference, value ? 1 : 0);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "org_apache_pdfbox_pdmodel_PDDocument_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ///
  /// Creates an empty PDF document.
  /// You need to add at least one page for the document to be valid.
  PDDocument() : super.fromRef(_ctor());

  static final _ctor1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)
  ///
  /// Creates an empty PDF document.
  /// You need to add at least one page for the document to be valid.
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  PDDocument.ctor1(jni.JlObject memUsageSetting)
      : super.fromRef(_ctor1(memUsageSetting.reference));

  static final _ctor2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_ctor2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(org.apache.pdfbox.cos.COSDocument doc)
  ///
  /// Constructor that uses an existing document. The COSDocument that is passed in must be valid.
  ///@param doc The COSDocument that this document wraps.
  PDDocument.ctor2(jni.JlObject doc) : super.fromRef(_ctor2(doc.reference));

  static final _ctor3 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_ctor3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(org.apache.pdfbox.cos.COSDocument doc, org.apache.pdfbox.io.RandomAccessRead source)
  ///
  /// Constructor that uses an existing document. The COSDocument that is passed in must be valid.
  ///@param doc The COSDocument that this document wraps.
  ///@param source the parser which is used to read the pdf
  PDDocument.ctor3(jni.JlObject doc, jni.JlObject source)
      : super.fromRef(_ctor3(doc.reference, source.reference));

  static final _ctor4 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_ctor4")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(org.apache.pdfbox.cos.COSDocument doc, org.apache.pdfbox.io.RandomAccessRead source, org.apache.pdfbox.pdmodel.encryption.AccessPermission permission)
  ///
  /// Constructor that uses an existing document. The COSDocument that is passed in must be valid.
  ///@param doc The COSDocument that this document wraps.
  ///@param source the parser which is used to read the pdf
  ///@param permission he access permissions of the pdf
  PDDocument.ctor4(
      jni.JlObject doc, jni.JlObject source, jni.JlObject permission)
      : super.fromRef(
            _ctor4(doc.reference, source.reference, permission.reference));

  static final _addPage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_addPage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addPage(org.apache.pdfbox.pdmodel.PDPage page)
  ///
  /// This will add a page to the document. This is a convenience method, that will add the page to the root of the
  /// hierarchy and set the parent of the page to the root.
  ///@param page The page to add to the document.
  void addPage(jni.JlObject page) => _addPage(reference, page.reference);

  static final _addSignature = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_addSignature")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject)
  ///
  /// Add parameters of signature to be created externally using default signature options. See
  /// \#saveIncrementalForExternalSigning(OutputStream) method description on external
  /// signature creation scenario details.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature(jni.JlObject sigObject) =>
      _addSignature(reference, sigObject.reference);

  static final _addSignature1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_addSignature1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions options)
  ///
  /// Add parameters of signature to be created externally. See
  /// \#saveIncrementalForExternalSigning(OutputStream) method description on external
  /// signature creation scenario details.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@param options signature options
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature1(jni.JlObject sigObject, jni.JlObject options) =>
      _addSignature1(reference, sigObject.reference, options.reference);

  static final _addSignature2 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_addSignature2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface signatureInterface)
  ///
  /// Add a signature to be created using the instance of given interface.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@param signatureInterface is an interface whose implementation provides
  /// signing capabilities. Can be null if external signing if used.
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature2(jni.JlObject sigObject, jni.JlObject signatureInterface) =>
      _addSignature2(
          reference, sigObject.reference, signatureInterface.reference);

  static final _addSignature3 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_addSignature3")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addSignature(org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface signatureInterface, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions options)
  ///
  /// This will add a signature to the document. If the 0-based page number in the options
  /// parameter is smaller than 0 or larger than max, the nearest valid page number will be used
  /// (i.e. 0 or max) and no exception will be thrown.
  ///
  /// Only one signature may be added in a document. To sign several times,
  /// load document, add signature, save incremental and close again.
  ///@param sigObject is the PDSignatureField model
  ///@param signatureInterface is an interface whose implementation provides
  /// signing capabilities. Can be null if external signing if used.
  ///@param options signature options
  ///@throws IOException if there is an error creating required fields
  ///@throws IllegalStateException if one attempts to add several signature
  /// fields.
  void addSignature3(jni.JlObject sigObject, jni.JlObject signatureInterface,
          jni.JlObject options) =>
      _addSignature3(reference, sigObject.reference,
          signatureInterface.reference, options.reference);

  static final _findSignatureField = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_findSignatureField")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField findSignatureField(java.util.Iterator<org.apache.pdfbox.pdmodel.interactive.form.PDField> fieldIterator, org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature sigObject)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Search acroform fields for signature field with specific signature dictionary.
  ///@param fieldIterator iterator on all fields.
  ///@param sigObject signature object (the /V part).
  ///@return a signature field if found, or null if none was found.
  jni.JlObject findSignatureField(
          jni.JlObject fieldIterator, jni.JlObject sigObject) =>
      jni.JlObject.fromRef(_findSignatureField(
          reference, fieldIterator.reference, sigObject.reference));

  static final _checkSignatureField = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_checkSignatureField")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: private boolean checkSignatureField(java.util.Iterator<org.apache.pdfbox.pdmodel.interactive.form.PDField> fieldIterator, org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField signatureField)
  ///
  /// Check if the field already exists in the field list.
  ///@param fieldIterator iterator on all fields.
  ///@param signatureField the signature field.
  ///@return true if the field already existed in the field list, false if not.
  bool checkSignatureField(
          jni.JlObject fieldIterator, jni.JlObject signatureField) =>
      _checkSignatureField(
          reference, fieldIterator.reference, signatureField.reference) !=
      0;

  static final _checkSignatureAnnotation = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_checkSignatureAnnotation")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: private boolean checkSignatureAnnotation(java.util.List<org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation> annotations, org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationWidget widget)
  ///
  /// Check if the widget already exists in the annotation list
  ///@param annotations the list of PDAnnotation fields.
  ///@param widget the annotation widget.
  ///@return true if the widget already existed in the annotation list, false if not.
  bool checkSignatureAnnotation(
          jni.JlObject annotations, jni.JlObject widget) =>
      _checkSignatureAnnotation(
          reference, annotations.reference, widget.reference) !=
      0;

  static final _prepareVisibleSignature = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_prepareVisibleSignature")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private void prepareVisibleSignature(org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField signatureField, org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm acroForm, org.apache.pdfbox.cos.COSDocument visualSignature)
  void prepareVisibleSignature(jni.JlObject signatureField,
          jni.JlObject acroForm, jni.JlObject visualSignature) =>
      _prepareVisibleSignature(reference, signatureField.reference,
          acroForm.reference, visualSignature.reference);

  static final _assignSignatureRectangle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_assignSignatureRectangle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: private void assignSignatureRectangle(org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField signatureField, org.apache.pdfbox.cos.COSDictionary annotDict)
  void assignSignatureRectangle(
          jni.JlObject signatureField, jni.JlObject annotDict) =>
      _assignSignatureRectangle(
          reference, signatureField.reference, annotDict.reference);

  static final _assignAppearanceDictionary = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_assignAppearanceDictionary")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: private void assignAppearanceDictionary(org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField signatureField, org.apache.pdfbox.cos.COSDictionary apDict)
  void assignAppearanceDictionary(
          jni.JlObject signatureField, jni.JlObject apDict) =>
      _assignAppearanceDictionary(
          reference, signatureField.reference, apDict.reference);

  static final _assignAcroFormDefaultResource = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_assignAcroFormDefaultResource")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: private void assignAcroFormDefaultResource(org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm acroForm, org.apache.pdfbox.cos.COSDictionary newDict)
  void assignAcroFormDefaultResource(
          jni.JlObject acroForm, jni.JlObject newDict) =>
      _assignAcroFormDefaultResource(
          reference, acroForm.reference, newDict.reference);

  static final _prepareNonVisibleSignature = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_prepareNonVisibleSignature")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private void prepareNonVisibleSignature(org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField signatureField)
  void prepareNonVisibleSignature(jni.JlObject signatureField) =>
      _prepareNonVisibleSignature(reference, signatureField.reference);

  static final _addSignatureField = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_addSignatureField")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addSignatureField(java.util.List<org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField> sigFields, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface signatureInterface, org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions options)
  ///
  /// This will add a list of signature fields to the document.
  ///@param sigFields are the PDSignatureFields that should be added to the document
  ///@param signatureInterface is an interface whose implementation provides
  /// signing capabilities. Can be null if external signing if used.
  ///@param options signature options
  ///@throws IOException if there is an error creating required fields
  ///@deprecated The method is misleading, because only one signature may be
  /// added in a document. The method will be removed in the future.
  void addSignatureField(jni.JlObject sigFields,
          jni.JlObject signatureInterface, jni.JlObject options) =>
      _addSignatureField(reference, sigFields.reference,
          signatureInterface.reference, options.reference);

  static final _removePage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_removePage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removePage(org.apache.pdfbox.pdmodel.PDPage page)
  ///
  /// Remove the page from the document.
  ///@param page The page to remove from the document.
  void removePage(jni.JlObject page) => _removePage(reference, page.reference);

  static final _removePage1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_removePage1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void removePage(int pageNumber)
  ///
  /// Remove the page from the document.
  ///@param pageNumber 0 based index to page number.
  void removePage1(int pageNumber) => _removePage1(reference, pageNumber);

  static final _importPage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_importPage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.PDPage importPage(org.apache.pdfbox.pdmodel.PDPage page)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will import and copy the contents from another location. Currently the content stream is
  /// stored in a scratch file. The scratch file is associated with the document. If you are adding
  /// a page to this document from another document and want to copy the contents to this
  /// document's scratch file then use this method otherwise just use the \#addPage addPage()
  /// method.
  ///
  /// Unlike \#addPage addPage(), this method creates a new PDPage object. If your page has
  /// annotations, and if these link to pages not in the target document, then the target document
  /// might become huge. What you need to do is to delete page references of such annotations. See
  /// <a href="http://stackoverflow.com/a/35477351/535646">here</a> for how to do this.
  ///
  /// Inherited (global) resources are ignored because these can contain resources not needed for
  /// this page which could bloat your document, see
  /// <a href="https://issues.apache.org/jira/browse/PDFBOX-28">PDFBOX-28</a> and related issues.
  /// If you need them, call <code>importedPage.setResources(page.getResources());</code>
  ///
  /// This method should only be used to import a page from a loaded document, not from a generated
  /// document because these can contain unfinished parts, e.g. font subsetting information.
  ///@param page The page to import.
  ///@return The page that was imported.
  ///@throws IOException If there is an error copying the page.
  jni.JlObject importPage(jni.JlObject page) =>
      jni.JlObject.fromRef(_importPage(reference, page.reference));

  static final _getDocument = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getDocument")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.cos.COSDocument getDocument()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the low level document.
  ///@return The document that this layer sits on top of.
  jni.JlObject getDocument() => jni.JlObject.fromRef(_getDocument(reference));

  static final _getDocumentInformation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getDocumentInformation")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.PDDocumentInformation getDocumentInformation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the document info dictionary. If it doesn't exist, an empty document info
  /// dictionary is created in the document trailer.
  ///
  /// In PDF 2.0 this is deprecated except for two entries, /CreationDate and /ModDate. For any other
  /// document level metadata, a metadata stream should be used instead, see
  /// PDDocumentCatalog\#getMetadata().
  ///@return The documents /Info dictionary, never null.
  PDDocumentInformation getDocumentInformation() =>
      PDDocumentInformation.fromRef(_getDocumentInformation(reference));

  static final _setDocumentInformation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_setDocumentInformation")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDocumentInformation(org.apache.pdfbox.pdmodel.PDDocumentInformation info)
  ///
  /// This will set the document information for this document.
  ///
  /// In PDF 2.0 this is deprecated except for two entries, /CreationDate and /ModDate. For any other
  /// document level metadata, a metadata stream should be used instead, see
  /// PDDocumentCatalog\#setMetadata(org.apache.pdfbox.pdmodel.common.PDMetadata) PDDocumentCatalog\#setMetadata(PDMetadata).
  ///@param info The updated document information.
  void setDocumentInformation(PDDocumentInformation info) =>
      _setDocumentInformation(reference, info.reference);

  static final _getDocumentCatalog = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getDocumentCatalog")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.PDDocumentCatalog getDocumentCatalog()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the document CATALOG. This is guaranteed to not return null.
  ///@return The documents /Root dictionary
  jni.JlObject getDocumentCatalog() =>
      jni.JlObject.fromRef(_getDocumentCatalog(reference));

  static final _isEncrypted =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_pdmodel_PDDocument_isEncrypted")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEncrypted()
  ///
  /// This will tell if this document is encrypted or not.
  ///@return true If this document is encrypted.
  bool isEncrypted() => _isEncrypted(reference) != 0;

  static final _getEncryption = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getEncryption")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.encryption.PDEncryption getEncryption()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the encryption dictionary for this document. This will still return the parameters if the document
  /// was decrypted. As the encryption architecture in PDF documents is pluggable this returns an abstract class,
  /// but the only supported subclass at this time is a
  /// PDStandardEncryption object.
  ///@return The encryption dictionary(most likely a PDStandardEncryption object)
  jni.JlObject getEncryption() =>
      jni.JlObject.fromRef(_getEncryption(reference));

  static final _setEncryptionDictionary = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_setEncryptionDictionary")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEncryptionDictionary(org.apache.pdfbox.pdmodel.encryption.PDEncryption encryption)
  ///
  /// This will set the encryption dictionary for this document.
  ///@param encryption The encryption dictionary(most likely a PDStandardEncryption object)
  ///@throws IOException If there is an error determining which security handler to use.
  void setEncryptionDictionary(jni.JlObject encryption) =>
      _setEncryptionDictionary(reference, encryption.reference);

  static final _getLastSignatureDictionary = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getLastSignatureDictionary")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature getLastSignatureDictionary()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will return the last signature from the field tree. Note that this may not be the
  /// last in time when empty signature fields are created first but signed after other fields.
  ///@return the last signature as <code>PDSignatureField</code>.
  ///@throws IOException if no document catalog can be found.
  jni.JlObject getLastSignatureDictionary() =>
      jni.JlObject.fromRef(_getLastSignatureDictionary(reference));

  static final _getSignatureFields = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getSignatureFields")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField> getSignatureFields()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all signature fields from the document.
  ///@return a <code>List</code> of <code>PDSignatureField</code>s
  ///@throws IOException if no document catalog can be found.
  jni.JlObject getSignatureFields() =>
      jni.JlObject.fromRef(_getSignatureFields(reference));

  static final _getSignatureDictionaries = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getSignatureDictionaries")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature> getSignatureDictionaries()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all signature dictionaries from the document.
  ///@return a <code>List</code> of <code>PDSignatureField</code>s
  ///@throws IOException if no document catalog can be found.
  jni.JlObject getSignatureDictionaries() =>
      jni.JlObject.fromRef(_getSignatureDictionaries(reference));

  static final _registerTrueTypeFontForClosing = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_registerTrueTypeFontForClosing")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerTrueTypeFontForClosing(org.apache.fontbox.ttf.TrueTypeFont ttf)
  ///
  /// For internal PDFBox use when creating PDF documents: register a TrueTypeFont to make sure it
  /// is closed when the PDDocument is closed to avoid memory leaks. Users don't have to call this
  /// method, it is done by the appropriate PDFont classes.
  ///@param ttf
  void registerTrueTypeFontForClosing(jni.JlObject ttf) =>
      _registerTrueTypeFontForClosing(reference, ttf.reference);

  static final _getFontsToSubset = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getFontsToSubset")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: java.util.Set<org.apache.pdfbox.pdmodel.font.PDFont> getFontsToSubset()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of fonts which will be subset before the document is saved.
  jni.JlObject getFontsToSubset() =>
      jni.JlObject.fromRef(_getFontsToSubset(reference));

  static final _load = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param file file to be loaded
  ///@return loaded document
  ///@throws InvalidPasswordException If the file required a non-empty password.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load(jni.JlObject file) =>
      PDDocument.fromRef(_load(file.reference));

  static final _load1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF.
  ///@param file file to be loaded
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the file required a non-empty password.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load1(jni.JlObject file, jni.JlObject memUsageSetting) =>
      PDDocument.fromRef(_load1(file.reference, memUsageSetting.reference));

  static final _load2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load2(jni.JlObject file, jni.JlString password) =>
      PDDocument.fromRef(_load2(file.reference, password.reference));

  static final _load3 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load3(jni.JlObject file, jni.JlString password,
          jni.JlObject memUsageSetting) =>
      PDDocument.fromRef(_load3(
          file.reference, password.reference, memUsageSetting.reference));

  static final _load4 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load4")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@return loaded document
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load4(jni.JlObject file, jni.JlString password,
          jni.JlObject keyStore, jni.JlString alias) =>
      PDDocument.fromRef(_load4(file.reference, password.reference,
          keyStore.reference, alias.reference));

  static final _load5 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load5")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.File file, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF.
  ///@param file file to be loaded
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@param memUsageSetting defines how memory is used for buffering PDF streams
  ///@return loaded document
  ///@throws IOException in case of a file reading or parsing error
  static PDDocument load5(
          jni.JlObject file,
          jni.JlString password,
          jni.JlObject keyStore,
          jni.JlString alias,
          jni.JlObject memUsageSetting) =>
      PDDocument.fromRef(_load5(file.reference, password.reference,
          keyStore.reference, alias.reference, memUsageSetting.reference));

  static final _load6 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load6")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: private static org.apache.pdfbox.pdmodel.PDDocument load(org.apache.pdfbox.io.RandomAccessBufferedFileInputStream raFile, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static PDDocument load6(
          jni.JlObject raFile,
          jni.JlString password,
          jni.JlObject keyStore,
          jni.JlString alias,
          jni.JlObject memUsageSetting) =>
      PDDocument.fromRef(_load6(raFile.reference, password.reference,
          keyStore.reference, alias.reference, memUsageSetting.reference));

  static final _load7 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load7")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. The given input stream is copied to the memory to enable random access to the
  /// pdf. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@return loaded document
  ///@throws InvalidPasswordException If the PDF required a non-empty password.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load7(jni.JlObject input) =>
      PDDocument.fromRef(_load7(input.reference));

  static final _load8 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load8")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. Depending on the memory settings parameter the given input stream is either
  /// copied to main memory or to a temporary file to enable random access to the pdf.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the PDF required a non-empty password.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load8(jni.JlObject input, jni.JlObject memUsageSetting) =>
      PDDocument.fromRef(_load8(input.reference, memUsageSetting.reference));

  static final _load9 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load9")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. The given input stream is copied to the memory to enable random access to the
  /// pdf. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load9(jni.JlObject input, jni.JlString password) =>
      PDDocument.fromRef(_load9(input.reference, password.reference));

  static final _load10 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load10")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. The given input stream is copied to the memory to enable random access to the
  /// pdf. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@return loaded document
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load10(jni.JlObject input, jni.JlString password,
          jni.JlObject keyStore, jni.JlString alias) =>
      PDDocument.fromRef(_load10(input.reference, password.reference,
          keyStore.reference, alias.reference));

  static final _load11 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load11")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. Depending on the memory settings parameter the given input stream is either
  /// copied to main memory or to a temporary file to enable random access to the pdf.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load11(jni.JlObject input, jni.JlString password,
          jni.JlObject memUsageSetting) =>
      PDDocument.fromRef(_load11(
          input.reference, password.reference, memUsageSetting.reference));

  static final _load12 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load12")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(java.io.InputStream input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. Depending on the memory settings parameter the given input stream is either
  /// copied to memory or to a temporary file to enable random access to the pdf.
  ///@param input stream that contains the document. Don't forget to close it after loading.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load12(
          jni.JlObject input,
          jni.JlString password,
          jni.JlObject keyStore,
          jni.JlString alias,
          jni.JlObject memUsageSetting) =>
      PDDocument.fromRef(_load12(input.reference, password.reference,
          keyStore.reference, alias.reference, memUsageSetting.reference));

  static final _load13 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load13")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input byte array that contains the document.
  ///@return loaded document
  ///@throws InvalidPasswordException If the PDF required a non-empty password.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load13(jni.JlObject input) =>
      PDDocument.fromRef(_load13(input.reference));

  static final _load14 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load14")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input, java.lang.String password)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input byte array that contains the document.
  ///@param password password to be used for decryption
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load14(jni.JlObject input, jni.JlString password) =>
      PDDocument.fromRef(_load14(input.reference, password.reference));

  static final _load15 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load15")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF. Unrestricted main memory will be used for buffering PDF streams.
  ///@param input byte array that contains the document.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load15(jni.JlObject input, jni.JlString password,
          jni.JlObject keyStore, jni.JlString alias) =>
      PDDocument.fromRef(_load15(input.reference, password.reference,
          keyStore.reference, alias.reference));

  static final _load16 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_load16")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public org.apache.pdfbox.pdmodel.PDDocument load(byte[] input, java.lang.String password, java.io.InputStream keyStore, java.lang.String alias, org.apache.pdfbox.io.MemoryUsageSetting memUsageSetting)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses a PDF.
  ///@param input byte array that contains the document.
  ///@param password password to be used for decryption
  ///@param keyStore key store to be used for decryption when using public key security
  ///@param alias alias to be used for decryption when using public key security
  ///@param memUsageSetting defines how memory is used for buffering input stream and PDF streams
  ///@return loaded document
  ///@throws InvalidPasswordException If the password is incorrect.
  ///@throws IOException In case of a reading or parsing error.
  static PDDocument load16(
          jni.JlObject input,
          jni.JlString password,
          jni.JlObject keyStore,
          jni.JlString alias,
          jni.JlObject memUsageSetting) =>
      PDDocument.fromRef(_load16(input.reference, password.reference,
          keyStore.reference, alias.reference, memUsageSetting.reference));

  static final _save = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_save")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void save(java.lang.String fileName)
  ///
  /// Save the document to a file.
  ///
  /// If encryption has been activated (with
  /// \#protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy) protect(ProtectionPolicy)),
  /// do not use the document after saving because the contents are now encrypted.
  ///@param fileName The file to save as.
  ///@throws IOException if the output could not be written
  void save(jni.JlString fileName) => _save(reference, fileName.reference);

  static final _save1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_save1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void save(java.io.File file)
  ///
  /// Save the document to a file.
  ///
  /// If encryption has been activated (with
  /// \#protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy) protect(ProtectionPolicy)),
  /// do not use the document after saving because the contents are now encrypted.
  ///@param file The file to save as.
  ///@throws IOException if the output could not be written
  void save1(jni.JlObject file) => _save1(reference, file.reference);

  static final _save2 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_save2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void save(java.io.OutputStream output)
  ///
  /// This will save the document to an output stream.
  ///
  /// If encryption has been activated (with
  /// \#protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy) protect(ProtectionPolicy)),
  /// do not use the document after saving because the contents are now encrypted.
  ///@param output The stream to write to. It will be closed when done. It is recommended to wrap
  /// it in a java.io.BufferedOutputStream, unless it is already buffered.
  ///@throws IOException if the output could not be written
  void save2(jni.JlObject output) => _save2(reference, output.reference);

  static final _saveIncremental = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_saveIncremental")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void saveIncremental(java.io.OutputStream output)
  ///
  /// Save the PDF as an incremental update. This is only possible if the PDF was loaded from a
  /// file or a stream, not if the document was created in PDFBox itself. There must be a path of
  /// objects that have COSUpdateInfo\#isNeedToBeUpdated() set, starting from the document
  /// catalog. For signatures this is taken care by PDFBox itself.
  ///
  /// Other usages of this method are for experienced users only. You will usually never need it.
  /// It is useful only if you are required to keep the current revision and append the changes. A
  /// typical use case is changing a signed file without invalidating the signature.
  ///@param output stream to write to. It will be closed when done. It
  /// <i>__must never__</i> point to the source file or that one will be
  /// harmed!
  ///@throws IOException if the output could not be written
  ///@throws IllegalStateException if the document was not loaded from a file or a stream.
  void saveIncremental(jni.JlObject output) =>
      _saveIncremental(reference, output.reference);

  static final _saveIncremental1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_saveIncremental1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void saveIncremental(java.io.OutputStream output, java.util.Set<org.apache.pdfbox.cos.COSDictionary> objectsToWrite)
  ///
  /// Save the PDF as an incremental update. This is only possible if the PDF was loaded from a
  /// file or a stream, not if the document was created in PDFBox itself. This allows to include
  /// objects even if there is no path of objects that have
  /// COSUpdateInfo\#isNeedToBeUpdated() set so the incremental update gets smaller. Only
  /// dictionaries are supported; if you need to update other objects classes, then add their
  /// parent dictionary.
  ///
  /// This method is for experienced users only. You will usually never need it. It is useful only
  /// if you are required to keep the current revision and append the changes. A typical use case
  /// is changing a signed file without invalidating the signature. To know which objects are
  /// getting changed, you need to have some understanding of the PDF specification, and look at
  /// the saved file with an editor to verify that you are updating the correct objects. You should
  /// also inspect the page and document structures of the file with PDFDebugger.
  ///@param output stream to write to. It will be closed when done. It
  /// <i>__must never__</i> point to the source file or that one will be harmed!
  ///@param objectsToWrite objects that __must__ be part of the incremental saving.
  ///@throws IOException if the output could not be written
  ///@throws IllegalStateException if the document was not loaded from a file or a stream.
  void saveIncremental1(jni.JlObject output, jni.JlObject objectsToWrite) =>
      _saveIncremental1(reference, output.reference, objectsToWrite.reference);

  static final _saveIncrementalForExternalSigning = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_saveIncrementalForExternalSigning")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.interactive.digitalsignature.ExternalSigningSupport saveIncrementalForExternalSigning(java.io.OutputStream output)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  /// __(This is a new feature for 2.0.3. The API for external signing might change based on feedback after release!)__
  ///
  /// Save PDF incrementally without closing for external signature creation scenario. The general
  /// sequence is:
  /// <pre>
  ///    PDDocument pdDocument = ...;
  ///    OutputStream outputStream = ...;
  ///    SignatureOptions signatureOptions = ...; // options to specify fine tuned signature options or null for defaults
  ///    PDSignature pdSignature = ...;
  ///
  ///    // add signature parameters to be used when creating signature dictionary
  ///    pdDocument.addSignature(pdSignature, signatureOptions);
  ///    // prepare PDF for signing and obtain helper class to be used
  ///    ExternalSigningSupport externalSigningSupport = pdDocument.saveIncrementalForExternalSigning(outputStream);
  ///    // get data to be signed
  ///    InputStream dataToBeSigned = externalSigningSupport.getContent();
  ///    // invoke signature service
  ///    byte[] signature = sign(dataToBeSigned);
  ///    // set resulted CMS signature
  ///    externalSigningSupport.setSignature(signature);
  ///
  ///    // last step is to close the document
  ///    pdDocument.close();
  /// </pre>
  ///
  /// Note that after calling this method, only {@code close()} method may invoked for
  /// {@code PDDocument} instance and only AFTER ExternalSigningSupport instance is used.
  ///
  ///
  ///@param output stream to write the final PDF. It will be closed when the
  /// document is closed. It <i>__must never__</i> point to the source file
  /// or that one will be harmed!
  ///@return instance to be used for external signing and setting CMS signature
  ///@throws IOException if the output could not be written
  ///@throws IllegalStateException if the document was not loaded from a file or a stream or
  /// signature options were not set.
  jni.JlObject saveIncrementalForExternalSigning(jni.JlObject output) =>
      jni.JlObject.fromRef(
          _saveIncrementalForExternalSigning(reference, output.reference));

  static final _getPage = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("org_apache_pdfbox_pdmodel_PDDocument_getPage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public org.apache.pdfbox.pdmodel.PDPage getPage(int pageIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the page at the given 0-based index.
  ///
  /// This method is too slow to get all the pages from a large PDF document
  /// (1000 pages or more). For such documents, use the iterator of
  /// PDDocument\#getPages() instead.
  ///@param pageIndex the 0-based page index
  ///@return the page at the given index.
  jni.JlObject getPage(int pageIndex) =>
      jni.JlObject.fromRef(_getPage(reference, pageIndex));

  static final _getPages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getPages")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.PDPageTree getPages()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the page tree.
  ///@return the page tree
  jni.JlObject getPages() => jni.JlObject.fromRef(_getPages(reference));

  static final _getNumberOfPages =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_pdmodel_PDDocument_getNumberOfPages")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getNumberOfPages()
  ///
  /// This will return the total page count of the PDF document.
  ///@return The total number of pages in the PDF document.
  int getNumberOfPages() => _getNumberOfPages(reference);

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_pdmodel_PDDocument_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  ///
  /// This will close the underlying COSDocument object.
  ///@throws IOException If there is an error releasing resources.
  void close() => _close(reference);

  static final _protect = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_protect")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void protect(org.apache.pdfbox.pdmodel.encryption.ProtectionPolicy policy)
  ///
  /// Protects the document with a protection policy. The document content will be really
  /// encrypted when it will be saved. This method only marks the document for encryption. It also
  /// calls \#setAllSecurityToBeRemoved(boolean) with a false argument if it was set to true
  /// previously and logs a warning.
  ///
  /// Do not use the document after saving, because the structures are encrypted.
  ///@see org.apache.pdfbox.pdmodel.encryption.StandardProtectionPolicy
  ///@see org.apache.pdfbox.pdmodel.encryption.PublicKeyProtectionPolicy
  ///@param policy The protection policy.
  ///@throws IOException if there isn't any suitable security handler.
  void protect(jni.JlObject policy) => _protect(reference, policy.reference);

  static final _getCurrentAccessPermission = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getCurrentAccessPermission")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.encryption.AccessPermission getCurrentAccessPermission()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the access permissions granted when the document was decrypted. If the document was not decrypted this
  /// method returns the access permission for a document owner (ie can do everything). The returned object is in read
  /// only mode so that permissions cannot be changed. Methods providing access to content should rely on this object
  /// to verify if the current user is allowed to proceed.
  ///@return the access permissions for the current user on the document.
  jni.JlObject getCurrentAccessPermission() =>
      jni.JlObject.fromRef(_getCurrentAccessPermission(reference));

  static final _isAllSecurityToBeRemoved =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_pdmodel_PDDocument_isAllSecurityToBeRemoved")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAllSecurityToBeRemoved()
  ///
  /// Indicates if all security is removed or not when writing the pdf.
  ///@return returns true if all security shall be removed otherwise false
  bool isAllSecurityToBeRemoved() => _isAllSecurityToBeRemoved(reference) != 0;

  static final _setAllSecurityToBeRemoved = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_setAllSecurityToBeRemoved")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAllSecurityToBeRemoved(boolean removeAllSecurity)
  ///
  /// Activates/Deactivates the removal of all security when writing the pdf.
  ///@param removeAllSecurity remove all security if set to true
  void setAllSecurityToBeRemoved(bool removeAllSecurity) =>
      _setAllSecurityToBeRemoved(reference, removeAllSecurity ? 1 : 0);

  static final _getDocumentId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getDocumentId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Long getDocumentId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provides the document ID.
  ///@return the document ID
  jni.JlObject getDocumentId() =>
      jni.JlObject.fromRef(_getDocumentId(reference));

  static final _setDocumentId = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_setDocumentId")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDocumentId(java.lang.Long docId)
  ///
  /// Sets the document ID to the given value.
  ///@param docId the new document ID
  void setDocumentId(jni.JlObject docId) =>
      _setDocumentId(reference, docId.reference);

  static final _getVersion =
      jlookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_pdmodel_PDDocument_getVersion")
          .asFunction<double Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getVersion()
  ///
  /// Returns the PDF specification version this document conforms to.
  ///@return the PDF version (e.g. 1.4f)
  double getVersion() => _getVersion(reference);

  static final _setVersion = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_setVersion")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setVersion(float newVersion)
  ///
  /// Sets the PDF specification version for this document.
  ///@param newVersion the new PDF version (e.g. 1.4f)
  void setVersion(double newVersion) => _setVersion(reference, newVersion);

  static final _getResourceCache = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_getResourceCache")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.ResourceCache getResourceCache()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the resource cache associated with this document, or null if there is none.
  ///@return the resource cache or null.
  jni.JlObject getResourceCache() =>
      jni.JlObject.fromRef(_getResourceCache(reference));

  static final _setResourceCache = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocument_setResourceCache")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setResourceCache(org.apache.pdfbox.pdmodel.ResourceCache resourceCache)
  ///
  /// Sets the resource cache associated with this document.
  ///@param resourceCache A resource cache, or null.
  void setResourceCache(jni.JlObject resourceCache) =>
      _setResourceCache(reference, resourceCache.reference);
}

/// from: org.apache.pdfbox.pdmodel.PDDocumentInformation
///
/// This is the document metadata.  Each getXXX method will return the entry if
/// it exists or null if it does not exist.  If you pass in null for the setXXX
/// method then it will clear the value.
///@author Ben Litchfield
///@author Gerardo Ortiz
class PDDocumentInformation extends jni.JlObject {
  PDDocumentInformation.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_info = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_pdmodel_PDDocumentInformation_info")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private final org.apache.pdfbox.cos.COSDictionary info
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get info => jni.JlObject.fromRef(_get_info(reference));

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "org_apache_pdfbox_pdmodel_PDDocumentInformation_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ///
  /// Default Constructor.
  PDDocumentInformation() : super.fromRef(_ctor());

  static final _ctor1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(org.apache.pdfbox.cos.COSDictionary dic)
  ///
  /// Constructor that is used for a preexisting dictionary.
  ///@param dic The underlying dictionary.
  PDDocumentInformation.ctor1(jni.JlObject dic)
      : super.fromRef(_ctor1(dic.reference));

  static final _getCOSObject = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getCOSObject")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.cos.COSDictionary getCOSObject()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the underlying dictionary that this object wraps.
  ///@return The underlying info dictionary.
  jni.JlObject getCOSObject() => jni.JlObject.fromRef(_getCOSObject(reference));

  static final _getPropertyStringValue = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getPropertyStringValue")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object getPropertyStringValue(java.lang.String propertyKey)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the properties String value.
  ///
  /// Allows to retrieve the
  /// low level date for validation purposes.
  ///
  ///
  ///@param propertyKey the dictionaries key
  ///@return the properties value
  jni.JlObject getPropertyStringValue(jni.JlString propertyKey) =>
      jni.JlObject.fromRef(
          _getPropertyStringValue(reference, propertyKey.reference));

  static final _getTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the title of the document.  This will return null if no title exists.
  ///@return The title of the document.
  jni.JlString getTitle() => jni.JlString.fromRef(_getTitle(reference));

  static final _setTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_setTitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.String title)
  ///
  /// This will set the title of the document.
  ///@param title The new title for the document.
  void setTitle(jni.JlString title) => _setTitle(reference, title.reference);

  static final _getAuthor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getAuthor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAuthor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the author of the document.  This will return null if no author exists.
  ///@return The author of the document.
  jni.JlString getAuthor() => jni.JlString.fromRef(_getAuthor(reference));

  static final _setAuthor = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_setAuthor")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setAuthor(java.lang.String author)
  ///
  /// This will set the author of the document.
  ///@param author The new author for the document.
  void setAuthor(jni.JlString author) =>
      _setAuthor(reference, author.reference);

  static final _getSubject = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getSubject")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSubject()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the subject of the document.  This will return null if no subject exists.
  ///@return The subject of the document.
  jni.JlString getSubject() => jni.JlString.fromRef(_getSubject(reference));

  static final _setSubject = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_setSubject")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSubject(java.lang.String subject)
  ///
  /// This will set the subject of the document.
  ///@param subject The new subject for the document.
  void setSubject(jni.JlString subject) =>
      _setSubject(reference, subject.reference);

  static final _getKeywords = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getKeywords")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getKeywords()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the keywords of the document.  This will return null if no keywords exists.
  ///@return The keywords of the document.
  jni.JlString getKeywords() => jni.JlString.fromRef(_getKeywords(reference));

  static final _setKeywords = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_setKeywords")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setKeywords(java.lang.String keywords)
  ///
  /// This will set the keywords of the document.
  ///@param keywords The new keywords for the document.
  void setKeywords(jni.JlString keywords) =>
      _setKeywords(reference, keywords.reference);

  static final _getCreator = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getCreator")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getCreator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the creator of the document.  This will return null if no creator exists.
  ///@return The creator of the document.
  jni.JlString getCreator() => jni.JlString.fromRef(_getCreator(reference));

  static final _setCreator = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_setCreator")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setCreator(java.lang.String creator)
  ///
  /// This will set the creator of the document.
  ///@param creator The new creator for the document.
  void setCreator(jni.JlString creator) =>
      _setCreator(reference, creator.reference);

  static final _getProducer = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getProducer")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getProducer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the producer of the document.  This will return null if no producer exists.
  ///@return The producer of the document.
  jni.JlString getProducer() => jni.JlString.fromRef(_getProducer(reference));

  static final _setProducer = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_setProducer")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setProducer(java.lang.String producer)
  ///
  /// This will set the producer of the document.
  ///@param producer The new producer for the document.
  void setProducer(jni.JlString producer) =>
      _setProducer(reference, producer.reference);

  static final _getCreationDate = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getCreationDate")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Calendar getCreationDate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the creation date of the document.  This will return null if no creation date exists.
  ///@return The creation date of the document.
  jni.JlObject getCreationDate() =>
      jni.JlObject.fromRef(_getCreationDate(reference));

  static final _setCreationDate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_setCreationDate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setCreationDate(java.util.Calendar date)
  ///
  /// This will set the creation date of the document.
  ///@param date The new creation date for the document.
  void setCreationDate(jni.JlObject date) =>
      _setCreationDate(reference, date.reference);

  static final _getModificationDate = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getModificationDate")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Calendar getModificationDate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the modification date of the document.  This will return null if no modification date exists.
  ///@return The modification date of the document.
  jni.JlObject getModificationDate() =>
      jni.JlObject.fromRef(_getModificationDate(reference));

  static final _setModificationDate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_setModificationDate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setModificationDate(java.util.Calendar date)
  ///
  /// This will set the modification date of the document.
  ///@param date The new modification date for the document.
  void setModificationDate(jni.JlObject date) =>
      _setModificationDate(reference, date.reference);

  static final _getTrapped = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getTrapped")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getTrapped()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the trapped value for the document.
  /// This will return null if one is not found.
  ///@return The trapped value for the document.
  jni.JlString getTrapped() => jni.JlString.fromRef(_getTrapped(reference));

  static final _getMetadataKeys = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getMetadataKeys")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set<java.lang.String> getMetadataKeys()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the keys of all metadata information fields for the document.
  ///@return all metadata key strings.
  ///@since Apache PDFBox 1.3.0
  jni.JlObject getMetadataKeys() =>
      jni.JlObject.fromRef(_getMetadataKeys(reference));

  static final _getCustomMetadataValue = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_getCustomMetadataValue")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getCustomMetadataValue(java.lang.String fieldName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the value of a custom metadata information field for the document.
  ///  This will return null if one is not found.
  ///@param fieldName Name of custom metadata field from pdf document.
  ///@return String Value of metadata field
  jni.JlString getCustomMetadataValue(jni.JlString fieldName) =>
      jni.JlString.fromRef(
          _getCustomMetadataValue(reference, fieldName.reference));

  static final _setCustomMetadataValue = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_setCustomMetadataValue")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setCustomMetadataValue(java.lang.String fieldName, java.lang.String fieldValue)
  ///
  /// Set the custom metadata value.
  ///@param fieldName The name of the custom metadata field.
  ///@param fieldValue The value to the custom metadata field.
  void setCustomMetadataValue(
          jni.JlString fieldName, jni.JlString fieldValue) =>
      _setCustomMetadataValue(
          reference, fieldName.reference, fieldValue.reference);

  static final _setTrapped = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_pdmodel_PDDocumentInformation_setTrapped")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTrapped(java.lang.String value)
  ///
  /// This will set the trapped of the document.  This will be
  /// 'True', 'False', or 'Unknown'.
  ///@param value The new trapped value for the document.
  ///@throws IllegalArgumentException if the parameter is invalid.
  void setTrapped(jni.JlString value) =>
      _setTrapped(reference, value.reference);
}
