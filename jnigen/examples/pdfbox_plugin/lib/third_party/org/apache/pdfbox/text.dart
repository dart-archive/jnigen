// Generated from Apache PDFBox library which is licensed under the Apache License 2.0.
// The following copyright from the original authors applies.
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;
import "package:jni/jni.dart" as jni;

import "../pdfbox/pdmodel.dart" as pdmodel_;
import "../../../_init.dart" show jlookup;

/// from: org.apache.pdfbox.text.PDFTextStripper
///
/// This class will take a pdf document and strip out all of the text and ignore the formatting and such. Please note; it
/// is up to clients of this class to verify that a specific user has the correct permissions to extract text from the
/// PDF document.
///
/// The basic flow of this process is that we get a document and use a series of processXXX() functions that work on
/// smaller and smaller chunks of the page. Eventually, we fully process each page and then print it.
///@author Ben Litchfield
class PDFTextStripper extends jni.JlObject {
  PDFTextStripper.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_defaultIndentThreshold = jlookup<
              ffi.NativeFunction<ffi.Float Function()>>(
          "get_org_apache_pdfbox_text_PDFTextStripper_defaultIndentThreshold")
      .asFunction<double Function()>();

  /// from: private static float defaultIndentThreshold
  static double get defaultIndentThreshold => _get_defaultIndentThreshold();
  static final _set_defaultIndentThreshold = jlookup<
              ffi.NativeFunction<ffi.Void Function(ffi.Float)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_defaultIndentThreshold")
      .asFunction<void Function(double)>();

  /// from: private static float defaultIndentThreshold
  static set defaultIndentThreshold(double value) =>
      _set_defaultIndentThreshold(value);

  static final _get_defaultDropThreshold =
      jlookup<ffi.NativeFunction<ffi.Float Function()>>(
              "get_org_apache_pdfbox_text_PDFTextStripper_defaultDropThreshold")
          .asFunction<double Function()>();

  /// from: private static float defaultDropThreshold
  static double get defaultDropThreshold => _get_defaultDropThreshold();
  static final _set_defaultDropThreshold =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Float)>>(
              "set_org_apache_pdfbox_text_PDFTextStripper_defaultDropThreshold")
          .asFunction<void Function(double)>();

  /// from: private static float defaultDropThreshold
  static set defaultDropThreshold(double value) =>
      _set_defaultDropThreshold(value);

  static final _get_LOG =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_org_apache_pdfbox_text_PDFTextStripper_LOG")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: private static final org.apache.commons.logging.Log LOG
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JlObject get LOG => jni.JlObject.fromRef(_get_LOG());

  static final _get_LINE_SEPARATOR = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_LINE_SEPARATOR")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: protected final java.lang.String LINE_SEPARATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The platform's line separator.
  jni.JlString get LINE_SEPARATOR =>
      jni.JlString.fromRef(_get_LINE_SEPARATOR(reference));

  static final _get_lineSeparator = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_lineSeparator")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.lang.String lineSeparator
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlString get lineSeparator =>
      jni.JlString.fromRef(_get_lineSeparator(reference));
  static final _set_lineSeparator = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_lineSeparator")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String lineSeparator
  /// The returned object must be deleted after use, by calling the `delete` method.
  set lineSeparator(jni.JlString value) =>
      _set_lineSeparator(reference, value.reference);

  static final _get_wordSeparator = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_wordSeparator")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.lang.String wordSeparator
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlString get wordSeparator =>
      jni.JlString.fromRef(_get_wordSeparator(reference));
  static final _set_wordSeparator = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_wordSeparator")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String wordSeparator
  /// The returned object must be deleted after use, by calling the `delete` method.
  set wordSeparator(jni.JlString value) =>
      _set_wordSeparator(reference, value.reference);

  static final _get_paragraphStart = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_paragraphStart")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.lang.String paragraphStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlString get paragraphStart =>
      jni.JlString.fromRef(_get_paragraphStart(reference));
  static final _set_paragraphStart = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_paragraphStart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String paragraphStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  set paragraphStart(jni.JlString value) =>
      _set_paragraphStart(reference, value.reference);

  static final _get_paragraphEnd = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_paragraphEnd")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.lang.String paragraphEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlString get paragraphEnd =>
      jni.JlString.fromRef(_get_paragraphEnd(reference));
  static final _set_paragraphEnd = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_paragraphEnd")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String paragraphEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  set paragraphEnd(jni.JlString value) =>
      _set_paragraphEnd(reference, value.reference);

  static final _get_pageStart = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_pageStart")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.lang.String pageStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlString get pageStart => jni.JlString.fromRef(_get_pageStart(reference));
  static final _set_pageStart = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_pageStart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String pageStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  set pageStart(jni.JlString value) =>
      _set_pageStart(reference, value.reference);

  static final _get_pageEnd = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_pageEnd")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.lang.String pageEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlString get pageEnd => jni.JlString.fromRef(_get_pageEnd(reference));
  static final _set_pageEnd = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_pageEnd")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String pageEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  set pageEnd(jni.JlString value) => _set_pageEnd(reference, value.reference);

  static final _get_articleStart = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_articleStart")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.lang.String articleStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlString get articleStart =>
      jni.JlString.fromRef(_get_articleStart(reference));
  static final _set_articleStart = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_articleStart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String articleStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  set articleStart(jni.JlString value) =>
      _set_articleStart(reference, value.reference);

  static final _get_articleEnd = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_articleEnd")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.lang.String articleEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlString get articleEnd =>
      jni.JlString.fromRef(_get_articleEnd(reference));
  static final _set_articleEnd = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_articleEnd")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String articleEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  set articleEnd(jni.JlString value) =>
      _set_articleEnd(reference, value.reference);

  static final _get_currentPageNo = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_currentPageNo")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private int currentPageNo
  int get currentPageNo => _get_currentPageNo(reference);
  static final _set_currentPageNo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_currentPageNo")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private int currentPageNo
  set currentPageNo(int value) => _set_currentPageNo(reference, value);

  static final _get_startPage = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_startPage")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private int startPage
  int get startPage => _get_startPage(reference);
  static final _set_startPage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_startPage")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private int startPage
  set startPage(int value) => _set_startPage(reference, value);

  static final _get_endPage = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_endPage")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private int endPage
  int get endPage => _get_endPage(reference);
  static final _set_endPage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_endPage")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private int endPage
  set endPage(int value) => _set_endPage(reference, value);

  static final _get_startBookmark = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_startBookmark")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem startBookmark
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get startBookmark =>
      jni.JlObject.fromRef(_get_startBookmark(reference));
  static final _set_startBookmark = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_startBookmark")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem startBookmark
  /// The returned object must be deleted after use, by calling the `delete` method.
  set startBookmark(jni.JlObject value) =>
      _set_startBookmark(reference, value.reference);

  static final _get_startBookmarkPageNumber = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_startBookmarkPageNumber")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private int startBookmarkPageNumber
  int get startBookmarkPageNumber => _get_startBookmarkPageNumber(reference);
  static final _set_startBookmarkPageNumber = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_startBookmarkPageNumber")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private int startBookmarkPageNumber
  set startBookmarkPageNumber(int value) =>
      _set_startBookmarkPageNumber(reference, value);

  static final _get_endBookmarkPageNumber = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_endBookmarkPageNumber")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private int endBookmarkPageNumber
  int get endBookmarkPageNumber => _get_endBookmarkPageNumber(reference);
  static final _set_endBookmarkPageNumber = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_endBookmarkPageNumber")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private int endBookmarkPageNumber
  set endBookmarkPageNumber(int value) =>
      _set_endBookmarkPageNumber(reference, value);

  static final _get_endBookmark = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_endBookmark")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem endBookmark
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get endBookmark =>
      jni.JlObject.fromRef(_get_endBookmark(reference));
  static final _set_endBookmark = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_endBookmark")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem endBookmark
  /// The returned object must be deleted after use, by calling the `delete` method.
  set endBookmark(jni.JlObject value) =>
      _set_endBookmark(reference, value.reference);

  static final _get_suppressDuplicateOverlappingText = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_suppressDuplicateOverlappingText")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private boolean suppressDuplicateOverlappingText
  bool get suppressDuplicateOverlappingText =>
      _get_suppressDuplicateOverlappingText(reference) != 0;
  static final _set_suppressDuplicateOverlappingText = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_suppressDuplicateOverlappingText")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private boolean suppressDuplicateOverlappingText
  set suppressDuplicateOverlappingText(bool value) =>
      _set_suppressDuplicateOverlappingText(reference, value ? 1 : 0);

  static final _get_shouldSeparateByBeads = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_shouldSeparateByBeads")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private boolean shouldSeparateByBeads
  bool get shouldSeparateByBeads => _get_shouldSeparateByBeads(reference) != 0;
  static final _set_shouldSeparateByBeads = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_shouldSeparateByBeads")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private boolean shouldSeparateByBeads
  set shouldSeparateByBeads(bool value) =>
      _set_shouldSeparateByBeads(reference, value ? 1 : 0);

  static final _get_sortByPosition = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_sortByPosition")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private boolean sortByPosition
  bool get sortByPosition => _get_sortByPosition(reference) != 0;
  static final _set_sortByPosition = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_sortByPosition")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private boolean sortByPosition
  set sortByPosition(bool value) =>
      _set_sortByPosition(reference, value ? 1 : 0);

  static final _get_addMoreFormatting = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_addMoreFormatting")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private boolean addMoreFormatting
  bool get addMoreFormatting => _get_addMoreFormatting(reference) != 0;
  static final _set_addMoreFormatting = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_addMoreFormatting")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private boolean addMoreFormatting
  set addMoreFormatting(bool value) =>
      _set_addMoreFormatting(reference, value ? 1 : 0);

  static final _get_indentThreshold = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_indentThreshold")
      .asFunction<
          double Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private float indentThreshold
  double get indentThreshold => _get_indentThreshold(reference);
  static final _set_indentThreshold = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_indentThreshold")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: private float indentThreshold
  set indentThreshold(double value) => _set_indentThreshold(reference, value);

  static final _get_dropThreshold = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_dropThreshold")
      .asFunction<
          double Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private float dropThreshold
  double get dropThreshold => _get_dropThreshold(reference);
  static final _set_dropThreshold = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_dropThreshold")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: private float dropThreshold
  set dropThreshold(double value) => _set_dropThreshold(reference, value);

  static final _get_spacingTolerance = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_spacingTolerance")
      .asFunction<
          double Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private float spacingTolerance
  double get spacingTolerance => _get_spacingTolerance(reference);
  static final _set_spacingTolerance = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_spacingTolerance")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: private float spacingTolerance
  set spacingTolerance(double value) => _set_spacingTolerance(reference, value);

  static final _get_averageCharTolerance = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_averageCharTolerance")
      .asFunction<
          double Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private float averageCharTolerance
  double get averageCharTolerance => _get_averageCharTolerance(reference);
  static final _set_averageCharTolerance = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_averageCharTolerance")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: private float averageCharTolerance
  set averageCharTolerance(double value) =>
      _set_averageCharTolerance(reference, value);

  static final _get_beadRectangles = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_beadRectangles")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.util.List<org.apache.pdfbox.pdmodel.common.PDRectangle> beadRectangles
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get beadRectangles =>
      jni.JlObject.fromRef(_get_beadRectangles(reference));
  static final _set_beadRectangles = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_beadRectangles")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.util.List<org.apache.pdfbox.pdmodel.common.PDRectangle> beadRectangles
  /// The returned object must be deleted after use, by calling the `delete` method.
  set beadRectangles(jni.JlObject value) =>
      _set_beadRectangles(reference, value.reference);

  static final _get_charactersByArticle = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_charactersByArticle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: protected java.util.ArrayList<java.util.List<org.apache.pdfbox.text.TextPosition>> charactersByArticle
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The charactersByArticle is used to extract text by article divisions. For example a PDF that has two columns like
  /// a newspaper, we want to extract the first column and then the second column. In this example the PDF would have 2
  /// beads(or articles), one for each column. The size of the charactersByArticle would be 5, because not all text on
  /// the screen will fall into one of the articles. The five divisions are shown below
  ///
  /// Text before first article
  /// first article text
  /// text between first article and second article
  /// second article text
  /// text after second article
  ///
  /// Most PDFs won't have any beads, so charactersByArticle will contain a single entry.
  jni.JlObject get charactersByArticle =>
      jni.JlObject.fromRef(_get_charactersByArticle(reference));
  static final _set_charactersByArticle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_charactersByArticle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected java.util.ArrayList<java.util.List<org.apache.pdfbox.text.TextPosition>> charactersByArticle
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The charactersByArticle is used to extract text by article divisions. For example a PDF that has two columns like
  /// a newspaper, we want to extract the first column and then the second column. In this example the PDF would have 2
  /// beads(or articles), one for each column. The size of the charactersByArticle would be 5, because not all text on
  /// the screen will fall into one of the articles. The five divisions are shown below
  ///
  /// Text before first article
  /// first article text
  /// text between first article and second article
  /// second article text
  /// text after second article
  ///
  /// Most PDFs won't have any beads, so charactersByArticle will contain a single entry.
  set charactersByArticle(jni.JlObject value) =>
      _set_charactersByArticle(reference, value.reference);

  static final _get_characterListMapping = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_characterListMapping")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.util.Map<java.lang.String,java.util.TreeMap<java.lang.Float,java.util.TreeSet<java.lang.Float>>> characterListMapping
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get characterListMapping =>
      jni.JlObject.fromRef(_get_characterListMapping(reference));
  static final _set_characterListMapping = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_characterListMapping")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.util.Map<java.lang.String,java.util.TreeMap<java.lang.Float,java.util.TreeSet<java.lang.Float>>> characterListMapping
  /// The returned object must be deleted after use, by calling the `delete` method.
  set characterListMapping(jni.JlObject value) =>
      _set_characterListMapping(reference, value.reference);

  static final _get_document = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_document")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: protected org.apache.pdfbox.pdmodel.PDDocument document
  /// The returned object must be deleted after use, by calling the `delete` method.
  pdmodel_.PDDocument get document =>
      pdmodel_.PDDocument.fromRef(_get_document(reference));
  static final _set_document = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_document")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected org.apache.pdfbox.pdmodel.PDDocument document
  /// The returned object must be deleted after use, by calling the `delete` method.
  set document(pdmodel_.PDDocument value) =>
      _set_document(reference, value.reference);

  static final _get_output = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_output")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: protected java.io.Writer output
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get output => jni.JlObject.fromRef(_get_output(reference));
  static final _set_output = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_output")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected java.io.Writer output
  /// The returned object must be deleted after use, by calling the `delete` method.
  set output(jni.JlObject value) => _set_output(reference, value.reference);

  static final _get_inParagraph = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_inParagraph")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private boolean inParagraph
  ///
  /// True if we started a paragraph but haven't ended it yet.
  bool get inParagraph => _get_inParagraph(reference) != 0;
  static final _set_inParagraph = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_inParagraph")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: private boolean inParagraph
  ///
  /// True if we started a paragraph but haven't ended it yet.
  set inParagraph(bool value) => _set_inParagraph(reference, value ? 1 : 0);

  /// from: private static final float END_OF_LAST_TEXT_X_RESET_VALUE
  static const END_OF_LAST_TEXT_X_RESET_VALUE = -1.0;

  /// from: private static final float MAX_Y_FOR_LINE_RESET_VALUE
  static const MAX_Y_FOR_LINE_RESET_VALUE = -3.4028235e+38;

  /// from: private static final float EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE
  static const EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE = -3.4028235e+38;

  /// from: private static final float MAX_HEIGHT_FOR_LINE_RESET_VALUE
  static const MAX_HEIGHT_FOR_LINE_RESET_VALUE = -1.0;

  /// from: private static final float MIN_Y_TOP_FOR_LINE_RESET_VALUE
  static const MIN_Y_TOP_FOR_LINE_RESET_VALUE = 3.4028235e+38;

  /// from: private static final float LAST_WORD_SPACING_RESET_VALUE
  static const LAST_WORD_SPACING_RESET_VALUE = -1.0;

  static final _get_LIST_ITEM_EXPRESSIONS = jlookup<
              ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          "get_org_apache_pdfbox_text_PDFTextStripper_LIST_ITEM_EXPRESSIONS")
      .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: private static final java.lang.String[] LIST_ITEM_EXPRESSIONS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// a list of regular expressions that match commonly used list item formats, i.e. bullets, numbers, letters, Roman
  /// numerals, etc. Not meant to be comprehensive.
  static jni.JlObject get LIST_ITEM_EXPRESSIONS =>
      jni.JlObject.fromRef(_get_LIST_ITEM_EXPRESSIONS());

  static final _get_listOfPatterns = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_org_apache_pdfbox_text_PDFTextStripper_listOfPatterns")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: private java.util.List<java.util.regex.Pattern> listOfPatterns
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JlObject get listOfPatterns =>
      jni.JlObject.fromRef(_get_listOfPatterns(reference));
  static final _set_listOfPatterns = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_org_apache_pdfbox_text_PDFTextStripper_listOfPatterns")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.util.List<java.util.regex.Pattern> listOfPatterns
  /// The returned object must be deleted after use, by calling the `delete` method.
  set listOfPatterns(jni.JlObject value) =>
      _set_listOfPatterns(reference, value.reference);

  static final _get_MIRRORING_CHAR_MAP =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_org_apache_pdfbox_text_PDFTextStripper_MIRRORING_CHAR_MAP")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: private static java.util.Map<java.lang.Character,java.lang.Character> MIRRORING_CHAR_MAP
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JlObject get MIRRORING_CHAR_MAP =>
      jni.JlObject.fromRef(_get_MIRRORING_CHAR_MAP());
  static final _set_MIRRORING_CHAR_MAP =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_org_apache_pdfbox_text_PDFTextStripper_MIRRORING_CHAR_MAP")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: private static java.util.Map<java.lang.Character,java.lang.Character> MIRRORING_CHAR_MAP
  /// The returned object must be deleted after use, by calling the `delete` method.
  static set MIRRORING_CHAR_MAP(jni.JlObject value) =>
      _set_MIRRORING_CHAR_MAP(value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "org_apache_pdfbox_text_PDFTextStripper_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ///
  /// Instantiate a new PDFTextStripper object.
  ///@throws IOException If there is an error loading the properties.
  PDFTextStripper() : super.fromRef(_ctor());

  static final _getText = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getText(org.apache.pdfbox.pdmodel.PDDocument doc)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will return the text of a document. See writeText. <br>
  /// NOTE: The document must not be encrypted when coming into this method.
  ///
  /// IMPORTANT: By default, text extraction is done in the same sequence as the text in the PDF page content stream.
  /// PDF is a graphic format, not a text format, and unlike HTML, it has no requirements that text one on page
  /// be rendered in a certain order. The order is the one that was determined by the software that created the
  /// PDF. To get text sorted from left to right and top to botton, use \#setSortByPosition(boolean).
  ///@param doc The document to get the text from.
  ///@return The text of the PDF document.
  ///@throws IOException if the doc state is invalid or it is encrypted.
  jni.JlString getText(pdmodel_.PDDocument doc) =>
      jni.JlString.fromRef(_getText(reference, doc.reference));

  static final _resetEngine =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_resetEngine")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: private void resetEngine()
  void resetEngine() => _resetEngine(reference);

  static final _writeText = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_writeText")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void writeText(org.apache.pdfbox.pdmodel.PDDocument doc, java.io.Writer outputStream)
  ///
  /// This will take a PDDocument and write the text of that document to the print writer.
  ///@param doc The document to get the data from.
  ///@param outputStream The location to put the text.
  ///@throws IOException If the doc is in an invalid state.
  void writeText(pdmodel_.PDDocument doc, jni.JlObject outputStream) =>
      _writeText(reference, doc.reference, outputStream.reference);

  static final _processPages = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_processPages")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void processPages(org.apache.pdfbox.pdmodel.PDPageTree pages)
  ///
  /// This will process all of the pages and the text that is in them.
  ///@param pages The pages object in the document.
  ///@throws IOException If there is an error parsing the text.
  void processPages(jni.JlObject pages) =>
      _processPages(reference, pages.reference);

  static final _startDocument = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_startDocument")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void startDocument(org.apache.pdfbox.pdmodel.PDDocument document)
  ///
  /// This method is available for subclasses of this class. It will be called before processing of the document start.
  ///@param document The PDF document that is being processed.
  ///@throws IOException If an IO error occurs.
  void startDocument(pdmodel_.PDDocument document) =>
      _startDocument(reference, document.reference);

  static final _endDocument = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_endDocument")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void endDocument(org.apache.pdfbox.pdmodel.PDDocument document)
  ///
  /// This method is available for subclasses of this class. It will be called after processing of the document
  /// finishes.
  ///@param document The PDF document that is being processed.
  ///@throws IOException If an IO error occurs.
  void endDocument(pdmodel_.PDDocument document) =>
      _endDocument(reference, document.reference);

  static final _processPage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_processPage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void processPage(org.apache.pdfbox.pdmodel.PDPage page)
  ///
  /// This will process the contents of a page.
  ///@param page The page to process.
  ///@throws IOException If there is an error processing the page.
  void processPage(jni.JlObject page) =>
      _processPage(reference, page.reference);

  static final _fillBeadRectangles = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_fillBeadRectangles")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private void fillBeadRectangles(org.apache.pdfbox.pdmodel.PDPage page)
  void fillBeadRectangles(jni.JlObject page) =>
      _fillBeadRectangles(reference, page.reference);

  static final _startArticle =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_startArticle")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void startArticle()
  ///
  /// Start a new article, which is typically defined as a column on a single page (also referred to as a bead). This
  /// assumes that the primary direction of text is left to right. Default implementation is to do nothing. Subclasses
  /// may provide additional information.
  ///@throws IOException If there is any error writing to the stream.
  void startArticle() => _startArticle(reference);

  static final _startArticle1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "org_apache_pdfbox_text_PDFTextStripper_startArticle1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected void startArticle(boolean isLTR)
  ///
  /// Start a new article, which is typically defined as a column on a single page (also referred to as a bead).
  /// Default implementation is to do nothing. Subclasses may provide additional information.
  ///@param isLTR true if primary direction of text is left to right.
  ///@throws IOException If there is any error writing to the stream.
  void startArticle1(bool isLTR) => _startArticle1(reference, isLTR ? 1 : 0);

  static final _endArticle =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_endArticle")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void endArticle()
  ///
  /// End an article. Default implementation is to do nothing. Subclasses may provide additional information.
  ///@throws IOException If there is any error writing to the stream.
  void endArticle() => _endArticle(reference);

  static final _startPage1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_startPage1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void startPage(org.apache.pdfbox.pdmodel.PDPage page)
  ///
  /// Start a new page. Default implementation is to do nothing. Subclasses may provide additional information.
  ///@param page The page we are about to process.
  ///@throws IOException If there is any error writing to the stream.
  void startPage1(jni.JlObject page) => _startPage1(reference, page.reference);

  static final _endPage1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_endPage1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void endPage(org.apache.pdfbox.pdmodel.PDPage page)
  ///
  /// End a page. Default implementation is to do nothing. Subclasses may provide additional information.
  ///@param page The page we are about to process.
  ///@throws IOException If there is any error writing to the stream.
  void endPage1(jni.JlObject page) => _endPage1(reference, page.reference);

  static final _writePage =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_writePage")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writePage()
  ///
  /// This will print the text of the processed page to "output". It will estimate, based on the coordinates of the
  /// text, where newlines and word spacings should be placed. The text will be sorted only if that feature was
  /// enabled.
  ///@throws IOException If there is an error writing the text.
  void writePage() => _writePage(reference);

  static final _overlap = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Float,
                  ffi.Float,
                  ffi.Float,
                  ffi.Float)>>("org_apache_pdfbox_text_PDFTextStripper_overlap")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, double, double, double, double)>();

  /// from: private boolean overlap(float y1, float height1, float y2, float height2)
  bool overlap(double y1, double height1, double y2, double height2) =>
      _overlap(reference, y1, height1, y2, height2) != 0;

  static final _writeLineSeparator =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_writeLineSeparator")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeLineSeparator()
  ///
  /// Write the line separator value to the output stream.
  ///@throws IOException If there is a problem writing out the line separator to the document.
  void writeLineSeparator() => _writeLineSeparator(reference);

  static final _writeWordSeparator =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_writeWordSeparator")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeWordSeparator()
  ///
  /// Write the word separator value to the output stream.
  ///@throws IOException If there is a problem writing out the word separator to the document.
  void writeWordSeparator() => _writeWordSeparator(reference);

  static final _writeCharacters = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_writeCharacters")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeCharacters(org.apache.pdfbox.text.TextPosition text)
  ///
  /// Write the string in TextPosition to the output stream.
  ///@param text The text to write to the stream.
  ///@throws IOException If there is an error when writing the text.
  void writeCharacters(jni.JlObject text) =>
      _writeCharacters(reference, text.reference);

  static final _writeString = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_writeString")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeString(java.lang.String text, java.util.List<org.apache.pdfbox.text.TextPosition> textPositions)
  ///
  /// Write a Java string to the output stream. The default implementation will ignore the <code>textPositions</code>
  /// and just calls \#writeString(String).
  ///@param text The text to write to the stream.
  ///@param textPositions The TextPositions belonging to the text.
  ///@throws IOException If there is an error when writing the text.
  void writeString(jni.JlString text, jni.JlObject textPositions) =>
      _writeString(reference, text.reference, textPositions.reference);

  static final _writeString1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_writeString1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeString(java.lang.String text)
  ///
  /// Write a Java string to the output stream.
  ///@param text The text to write to the stream.
  ///@throws IOException If there is an error when writing the text.
  void writeString1(jni.JlString text) =>
      _writeString1(reference, text.reference);

  static final _within = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Float, ffi.Float,
                  ffi.Float)>>("org_apache_pdfbox_text_PDFTextStripper_within")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, double, double, double)>();

  /// from: private boolean within(float first, float second, float variance)
  ///
  /// This will determine of two floating point numbers are within a specified variance.
  ///@param first The first number to compare to.
  ///@param second The second number to compare to.
  ///@param variance The allowed variance.
  bool within(double first, double second, double variance) =>
      _within(reference, first, second, variance) != 0;

  static final _processTextPosition = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_processTextPosition")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void processTextPosition(org.apache.pdfbox.text.TextPosition text)
  ///
  /// This will process a TextPosition object and add the text to the list of characters on a page. It takes care of
  /// overlapping text.
  ///@param text The text to process.
  void processTextPosition(jni.JlObject text) =>
      _processTextPosition(reference, text.reference);

  static final _getStartPage =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_getStartPage")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getStartPage()
  ///
  /// This is the page that the text extraction will start on. The pages start at page 1. For example in a 5 page PDF
  /// document, if the start page is 1 then all pages will be extracted. If the start page is 4 then pages 4 and 5 will
  /// be extracted. The default value is 1.
  ///@return Value of property startPage.
  int getStartPage() => _getStartPage(reference);

  static final _setStartPage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setStartPage")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setStartPage(int startPageValue)
  ///
  /// This will set the first page to be extracted by this class.
  ///@param startPageValue New value of 1-based startPage property.
  void setStartPage(int startPageValue) =>
      _setStartPage(reference, startPageValue);

  static final _getEndPage =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_getEndPage")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getEndPage()
  ///
  /// This will get the last page that will be extracted. This is inclusive, for example if a 5 page PDF an endPage
  /// value of 5 would extract the entire document, an end page of 2 would extract pages 1 and 2. This defaults to
  /// Integer.MAX_VALUE such that all pages of the pdf will be extracted.
  ///@return Value of property endPage.
  int getEndPage() => _getEndPage(reference);

  static final _setEndPage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setEndPage")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setEndPage(int endPageValue)
  ///
  /// This will set the last page to be extracted by this class.
  ///@param endPageValue New value of 1-based endPage property.
  void setEndPage(int endPageValue) => _setEndPage(reference, endPageValue);

  static final _setLineSeparator = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setLineSeparator")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setLineSeparator(java.lang.String separator)
  ///
  /// Set the desired line separator for output text. The line.separator system property is used if the line separator
  /// preference is not set explicitly using this method.
  ///@param separator The desired line separator string.
  void setLineSeparator(jni.JlString separator) =>
      _setLineSeparator(reference, separator.reference);

  static final _getLineSeparator = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getLineSeparator")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLineSeparator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the line separator.
  ///@return The desired line separator string.
  jni.JlString getLineSeparator() =>
      jni.JlString.fromRef(_getLineSeparator(reference));

  static final _getWordSeparator = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getWordSeparator")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getWordSeparator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the word separator.
  ///@return The desired word separator string.
  jni.JlString getWordSeparator() =>
      jni.JlString.fromRef(_getWordSeparator(reference));

  static final _setWordSeparator = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setWordSeparator")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setWordSeparator(java.lang.String separator)
  ///
  /// Set the desired word separator for output text. The PDFBox text extraction algorithm will output a space
  /// character if there is enough space between two words. By default a space character is used. If you need and
  /// accurate count of characters that are found in a PDF document then you might want to set the word separator to
  /// the empty string.
  ///@param separator The desired page separator string.
  void setWordSeparator(jni.JlString separator) =>
      _setWordSeparator(reference, separator.reference);

  static final _getSuppressDuplicateOverlappingText = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getSuppressDuplicateOverlappingText")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getSuppressDuplicateOverlappingText()
  ///
  /// @return Returns the suppressDuplicateOverlappingText.
  bool getSuppressDuplicateOverlappingText() =>
      _getSuppressDuplicateOverlappingText(reference) != 0;

  static final _getCurrentPageNo =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_getCurrentPageNo")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected int getCurrentPageNo()
  ///
  /// Get the current page number that is being processed.
  ///@return A 1 based number representing the current page.
  int getCurrentPageNo() => _getCurrentPageNo(reference);

  static final _getOutput = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getOutput")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected java.io.Writer getOutput()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The output stream that is being written to.
  ///@return The stream that output is being written to.
  jni.JlObject getOutput() => jni.JlObject.fromRef(_getOutput(reference));

  static final _getCharactersByArticle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getCharactersByArticle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected java.util.List<java.util.List<org.apache.pdfbox.text.TextPosition>> getCharactersByArticle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Character strings are grouped by articles. It is quite common that there will only be a single article. This
  /// returns a List that contains List objects, the inner lists will contain TextPosition objects.
  ///@return A double List of TextPositions for all text strings on the page.
  jni.JlObject getCharactersByArticle() =>
      jni.JlObject.fromRef(_getCharactersByArticle(reference));

  static final _setSuppressDuplicateOverlappingText = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setSuppressDuplicateOverlappingText")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSuppressDuplicateOverlappingText(boolean suppressDuplicateOverlappingTextValue)
  ///
  /// By default the text stripper will attempt to remove text that overlapps each other. Word paints the same
  /// character several times in order to make it look bold. By setting this to false all text will be extracted, which
  /// means that certain sections will be duplicated, but better performance will be noticed.
  ///@param suppressDuplicateOverlappingTextValue The suppressDuplicateOverlappingText to set.
  void setSuppressDuplicateOverlappingText(
          bool suppressDuplicateOverlappingTextValue) =>
      _setSuppressDuplicateOverlappingText(
          reference, suppressDuplicateOverlappingTextValue ? 1 : 0);

  static final _getSeparateByBeads =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_getSeparateByBeads")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getSeparateByBeads()
  ///
  /// This will tell if the text stripper should separate by beads.
  ///@return If the text will be grouped by beads.
  bool getSeparateByBeads() => _getSeparateByBeads(reference) != 0;

  static final _setShouldSeparateByBeads = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setShouldSeparateByBeads")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setShouldSeparateByBeads(boolean aShouldSeparateByBeads)
  ///
  /// Set if the text stripper should group the text output by a list of beads. The default value is true!
  ///@param aShouldSeparateByBeads The new grouping of beads.
  void setShouldSeparateByBeads(bool aShouldSeparateByBeads) =>
      _setShouldSeparateByBeads(reference, aShouldSeparateByBeads ? 1 : 0);

  static final _getEndBookmark = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getEndBookmark")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem getEndBookmark()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the bookmark where text extraction should end, inclusive. Default is null.
  ///@return The ending bookmark.
  jni.JlObject getEndBookmark() =>
      jni.JlObject.fromRef(_getEndBookmark(reference));

  static final _setEndBookmark = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setEndBookmark")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEndBookmark(org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem aEndBookmark)
  ///
  /// Set the bookmark where the text extraction should stop.
  ///@param aEndBookmark The ending bookmark.
  void setEndBookmark(jni.JlObject aEndBookmark) =>
      _setEndBookmark(reference, aEndBookmark.reference);

  static final _getStartBookmark = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getStartBookmark")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem getStartBookmark()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the bookmark where text extraction should start, inclusive. Default is null.
  ///@return The starting bookmark.
  jni.JlObject getStartBookmark() =>
      jni.JlObject.fromRef(_getStartBookmark(reference));

  static final _setStartBookmark = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setStartBookmark")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setStartBookmark(org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem aStartBookmark)
  ///
  /// Set the bookmark where text extraction should start, inclusive.
  ///@param aStartBookmark The starting bookmark.
  void setStartBookmark(jni.JlObject aStartBookmark) =>
      _setStartBookmark(reference, aStartBookmark.reference);

  static final _getAddMoreFormatting =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_getAddMoreFormatting")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAddMoreFormatting()
  ///
  /// This will tell if the text stripper should add some more text formatting.
  ///@return true if some more text formatting will be added
  bool getAddMoreFormatting() => _getAddMoreFormatting(reference) != 0;

  static final _setAddMoreFormatting = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setAddMoreFormatting")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAddMoreFormatting(boolean newAddMoreFormatting)
  ///
  /// There will some additional text formatting be added if addMoreFormatting is set to true. Default is false.
  ///@param newAddMoreFormatting Tell PDFBox to add some more text formatting
  void setAddMoreFormatting(bool newAddMoreFormatting) =>
      _setAddMoreFormatting(reference, newAddMoreFormatting ? 1 : 0);

  static final _getSortByPosition =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_getSortByPosition")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getSortByPosition()
  ///
  /// This will tell if the text stripper should sort the text tokens before writing to the stream.
  ///@return true If the text tokens will be sorted before being written.
  bool getSortByPosition() => _getSortByPosition(reference) != 0;

  static final _setSortByPosition = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setSortByPosition")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSortByPosition(boolean newSortByPosition)
  ///
  /// The order of the text tokens in a PDF file may not be in the same as they appear visually on the screen. For
  /// example, a PDF writer may write out all text by font, so all bold or larger text, then make a second pass and
  /// write out the normal text.<br>
  /// The default is to __not__ sort by position.<br>
  /// <br>
  /// A PDF writer could choose to write each character in a different order. By default PDFBox does __not__ sort
  /// the text tokens before processing them due to performance reasons.
  ///@param newSortByPosition Tell PDFBox to sort the text positions.
  void setSortByPosition(bool newSortByPosition) =>
      _setSortByPosition(reference, newSortByPosition ? 1 : 0);

  static final _getSpacingTolerance =
      jlookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_getSpacingTolerance")
          .asFunction<double Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getSpacingTolerance()
  ///
  /// Get the current space width-based tolerance value that is being used to estimate where spaces in text should be
  /// added. Note that the default value for this has been determined from trial and error.
  ///@return The current tolerance / scaling factor
  double getSpacingTolerance() => _getSpacingTolerance(reference);

  static final _setSpacingTolerance = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setSpacingTolerance")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setSpacingTolerance(float spacingToleranceValue)
  ///
  /// Set the space width-based tolerance value that is used to estimate where spaces in text should be added. Note
  /// that the default value for this has been determined from trial and error. Setting this value larger will reduce
  /// the number of spaces added.
  ///@param spacingToleranceValue tolerance / scaling factor to use
  void setSpacingTolerance(double spacingToleranceValue) =>
      _setSpacingTolerance(reference, spacingToleranceValue);

  static final _getAverageCharTolerance =
      jlookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_getAverageCharTolerance")
          .asFunction<double Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getAverageCharTolerance()
  ///
  /// Get the current character width-based tolerance value that is being used to estimate where spaces in text should
  /// be added. Note that the default value for this has been determined from trial and error.
  ///@return The current tolerance / scaling factor
  double getAverageCharTolerance() => _getAverageCharTolerance(reference);

  static final _setAverageCharTolerance = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setAverageCharTolerance")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setAverageCharTolerance(float averageCharToleranceValue)
  ///
  /// Set the character width-based tolerance value that is used to estimate where spaces in text should be added. Note
  /// that the default value for this has been determined from trial and error. Setting this value larger will reduce
  /// the number of spaces added.
  ///@param averageCharToleranceValue average tolerance / scaling factor to use
  void setAverageCharTolerance(double averageCharToleranceValue) =>
      _setAverageCharTolerance(reference, averageCharToleranceValue);

  static final _getIndentThreshold =
      jlookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_getIndentThreshold")
          .asFunction<double Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getIndentThreshold()
  ///
  /// returns the multiple of whitespace character widths for the current text which the current line start can be
  /// indented from the previous line start beyond which the current line start is considered to be a paragraph start.
  ///@return the number of whitespace character widths to use when detecting paragraph indents.
  double getIndentThreshold() => _getIndentThreshold(reference);

  static final _setIndentThreshold = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setIndentThreshold")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setIndentThreshold(float indentThresholdValue)
  ///
  /// sets the multiple of whitespace character widths for the current text which the current line start can be
  /// indented from the previous line start beyond which the current line start is considered to be a paragraph start.
  /// The default value is 2.0.
  ///@param indentThresholdValue the number of whitespace character widths to use when detecting paragraph indents.
  void setIndentThreshold(double indentThresholdValue) =>
      _setIndentThreshold(reference, indentThresholdValue);

  static final _getDropThreshold =
      jlookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_getDropThreshold")
          .asFunction<double Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getDropThreshold()
  ///
  /// the minimum whitespace, as a multiple of the max height of the current characters beyond which the current line
  /// start is considered to be a paragraph start.
  ///@return the character height multiple for max allowed whitespace between lines in the same paragraph.
  double getDropThreshold() => _getDropThreshold(reference);

  static final _setDropThreshold = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setDropThreshold")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setDropThreshold(float dropThresholdValue)
  ///
  /// sets the minimum whitespace, as a multiple of the max height of the current characters beyond which the current
  /// line start is considered to be a paragraph start. The default value is 2.5.
  ///@param dropThresholdValue the character height multiple for max allowed whitespace between lines in the same
  /// paragraph.
  void setDropThreshold(double dropThresholdValue) =>
      _setDropThreshold(reference, dropThresholdValue);

  static final _getParagraphStart = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getParagraphStart")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getParagraphStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the beginning of a paragraph.
  ///@return the paragraph start string
  jni.JlString getParagraphStart() =>
      jni.JlString.fromRef(_getParagraphStart(reference));

  static final _setParagraphStart = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setParagraphStart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setParagraphStart(java.lang.String s)
  ///
  /// Sets the string which will be used at the beginning of a paragraph.
  ///@param s the paragraph start string
  void setParagraphStart(jni.JlString s) =>
      _setParagraphStart(reference, s.reference);

  static final _getParagraphEnd = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getParagraphEnd")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getParagraphEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the end of a paragraph.
  ///@return the paragraph end string
  jni.JlString getParagraphEnd() =>
      jni.JlString.fromRef(_getParagraphEnd(reference));

  static final _setParagraphEnd = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setParagraphEnd")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setParagraphEnd(java.lang.String s)
  ///
  /// Sets the string which will be used at the end of a paragraph.
  ///@param s the paragraph end string
  void setParagraphEnd(jni.JlString s) =>
      _setParagraphEnd(reference, s.reference);

  static final _getPageStart = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getPageStart")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPageStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the beginning of a page.
  ///@return the page start string
  jni.JlString getPageStart() => jni.JlString.fromRef(_getPageStart(reference));

  static final _setPageStart = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setPageStart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setPageStart(java.lang.String pageStartValue)
  ///
  /// Sets the string which will be used at the beginning of a page.
  ///@param pageStartValue the page start string
  void setPageStart(jni.JlString pageStartValue) =>
      _setPageStart(reference, pageStartValue.reference);

  static final _getPageEnd = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getPageEnd")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPageEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the end of a page.
  ///@return the page end string
  jni.JlString getPageEnd() => jni.JlString.fromRef(_getPageEnd(reference));

  static final _setPageEnd = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setPageEnd")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setPageEnd(java.lang.String pageEndValue)
  ///
  /// Sets the string which will be used at the end of a page.
  ///@param pageEndValue the page end string
  void setPageEnd(jni.JlString pageEndValue) =>
      _setPageEnd(reference, pageEndValue.reference);

  static final _getArticleStart = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getArticleStart")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getArticleStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the beginning of an article.
  ///@return the article start string
  jni.JlString getArticleStart() =>
      jni.JlString.fromRef(_getArticleStart(reference));

  static final _setArticleStart = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setArticleStart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setArticleStart(java.lang.String articleStartValue)
  ///
  /// Sets the string which will be used at the beginning of an article.
  ///@param articleStartValue the article start string
  void setArticleStart(jni.JlString articleStartValue) =>
      _setArticleStart(reference, articleStartValue.reference);

  static final _getArticleEnd = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getArticleEnd")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getArticleEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the end of an article.
  ///@return the article end string
  jni.JlString getArticleEnd() =>
      jni.JlString.fromRef(_getArticleEnd(reference));

  static final _setArticleEnd = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setArticleEnd")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setArticleEnd(java.lang.String articleEndValue)
  ///
  /// Sets the string which will be used at the end of an article.
  ///@param articleEndValue the article end string
  void setArticleEnd(jni.JlString articleEndValue) =>
      _setArticleEnd(reference, articleEndValue.reference);

  static final _handleLineSeparation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Float)>>(
          "org_apache_pdfbox_text_PDFTextStripper_handleLineSeparation")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              double)>();

  /// from: private org.apache.pdfbox.text.PDFTextStripper.PositionWrapper handleLineSeparation(org.apache.pdfbox.text.PDFTextStripper.PositionWrapper current, org.apache.pdfbox.text.PDFTextStripper.PositionWrapper lastPosition, org.apache.pdfbox.text.PDFTextStripper.PositionWrapper lastLineStartPosition, float maxHeightForLine)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// handles the line separator for a new line given the specified current and previous TextPositions.
  ///@param current the current text position
  ///@param lastPosition the previous text position
  ///@param lastLineStartPosition the last text position that followed a line separator.
  ///@param maxHeightForLine max height for positions since lastLineStartPosition
  ///@return start position of the last line
  ///@throws IOException if something went wrong
  jni.JlObject handleLineSeparation(
          jni.JlObject current,
          jni.JlObject lastPosition,
          jni.JlObject lastLineStartPosition,
          double maxHeightForLine) =>
      jni.JlObject.fromRef(_handleLineSeparation(
          reference,
          current.reference,
          lastPosition.reference,
          lastLineStartPosition.reference,
          maxHeightForLine));

  static final _isParagraphSeparation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Float)>>(
          "org_apache_pdfbox_text_PDFTextStripper_isParagraphSeparation")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: private void isParagraphSeparation(org.apache.pdfbox.text.PDFTextStripper.PositionWrapper position, org.apache.pdfbox.text.PDFTextStripper.PositionWrapper lastPosition, org.apache.pdfbox.text.PDFTextStripper.PositionWrapper lastLineStartPosition, float maxHeightForLine)
  ///
  /// tests the relationship between the last text position, the current text position and the last text position that
  /// followed a line separator to decide if the gap represents a paragraph separation. This should <i>only</i> be
  /// called for consecutive text positions that first pass the line separation test.
  ///
  /// This base implementation tests to see if the lastLineStartPosition is null OR if the current vertical position
  /// has dropped below the last text vertical position by at least 2.5 times the current text height OR if the current
  /// horizontal position is indented by at least 2 times the current width of a space character.
  ///
  ///
  ///
  /// This also attempts to identify text that is indented under a hanging indent.
  ///
  ///
  ///
  /// This method sets the isParagraphStart and isHangingIndent flags on the current position object.
  ///
  ///
  ///@param position the current text position. This may have its isParagraphStart or isHangingIndent flags set upon
  /// return.
  ///@param lastPosition the previous text position (should not be null).
  ///@param lastLineStartPosition the last text position that followed a line separator, or null.
  ///@param maxHeightForLine max height for text positions since lasLineStartPosition.
  void isParagraphSeparation(jni.JlObject position, jni.JlObject lastPosition,
          jni.JlObject lastLineStartPosition, double maxHeightForLine) =>
      _isParagraphSeparation(
          reference,
          position.reference,
          lastPosition.reference,
          lastLineStartPosition.reference,
          maxHeightForLine);

  static final _multiplyFloat = jlookup<
              ffi.NativeFunction<
                  ffi.Float Function(
                      ffi.Pointer<ffi.Void>, ffi.Float, ffi.Float)>>(
          "org_apache_pdfbox_text_PDFTextStripper_multiplyFloat")
      .asFunction<double Function(ffi.Pointer<ffi.Void>, double, double)>();

  /// from: private float multiplyFloat(float value1, float value2)
  double multiplyFloat(double value1, double value2) =>
      _multiplyFloat(reference, value1, value2);

  static final _writeParagraphSeparator =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_writeParagraphSeparator")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeParagraphSeparator()
  ///
  /// writes the paragraph separator string to the output.
  ///@throws IOException if something went wrong
  void writeParagraphSeparator() => _writeParagraphSeparator(reference);

  static final _writeParagraphStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_writeParagraphStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeParagraphStart()
  ///
  /// Write something (if defined) at the start of a paragraph.
  ///@throws IOException if something went wrong
  void writeParagraphStart() => _writeParagraphStart(reference);

  static final _writeParagraphEnd =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_writeParagraphEnd")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeParagraphEnd()
  ///
  /// Write something (if defined) at the end of a paragraph.
  ///@throws IOException if something went wrong
  void writeParagraphEnd() => _writeParagraphEnd(reference);

  static final _writePageStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_writePageStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writePageStart()
  ///
  /// Write something (if defined) at the start of a page.
  ///@throws IOException if something went wrong
  void writePageStart() => _writePageStart(reference);

  static final _writePageEnd =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_writePageEnd")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writePageEnd()
  ///
  /// Write something (if defined) at the end of a page.
  ///@throws IOException if something went wrong
  void writePageEnd() => _writePageEnd(reference);

  static final _matchListItemPattern = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_matchListItemPattern")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.util.regex.Pattern matchListItemPattern(org.apache.pdfbox.text.PDFTextStripper.PositionWrapper pw)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// returns the list item Pattern object that matches the text at the specified PositionWrapper or null if the text
  /// does not match such a pattern. The list of Patterns tested against is given by the \#getListItemPatterns()
  /// method. To add to the list, simply override that method (if sub-classing) or explicitly supply your own list
  /// using \#setListItemPatterns(List).
  ///@param pw position
  ///@return the matching pattern
  jni.JlObject matchListItemPattern(jni.JlObject pw) =>
      jni.JlObject.fromRef(_matchListItemPattern(reference, pw.reference));

  static final _setListItemPatterns = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_setListItemPatterns")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void setListItemPatterns(java.util.List<java.util.regex.Pattern> patterns)
  ///
  /// use to supply a different set of regular expression patterns for matching list item starts.
  ///@param patterns list of patterns
  void setListItemPatterns(jni.JlObject patterns) =>
      _setListItemPatterns(reference, patterns.reference);

  static final _getListItemPatterns = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_getListItemPatterns")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected java.util.List<java.util.regex.Pattern> getListItemPatterns()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// returns a list of regular expression Patterns representing different common list item formats. For example
  /// numbered items of form:
  /// <ol>
  /// <li>some text</li>
  /// <li>more text</li>
  /// </ol>
  /// or
  /// <ul>
  /// <li>some text</li>
  /// <li>more text</li>
  /// </ul>
  /// etc., all begin with some character pattern. The pattern "\\d+\." (matches "1.", "2.", ...) or "\[\\d+\]"
  /// (matches "[1]", "[2]", ...).
  ///
  /// This method returns a list of such regular expression Patterns.
  ///@return a list of Pattern objects.
  jni.JlObject getListItemPatterns() =>
      jni.JlObject.fromRef(_getListItemPatterns(reference));

  static final _matchPattern = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_matchPattern")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static protected java.util.regex.Pattern matchPattern(java.lang.String string, java.util.List<java.util.regex.Pattern> patterns)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// iterates over the specified list of Patterns until it finds one that matches the specified string. Then returns
  /// the Pattern.
  ///
  /// Order of the supplied list of patterns is important as most common patterns should come first. Patterns should be
  /// strict in general, and all will be used with case sensitivity on.
  ///
  ///
  ///@param string the string to be searched
  ///@param patterns list of patterns
  ///@return matching pattern
  static jni.JlObject matchPattern(
          jni.JlString string, jni.JlObject patterns) =>
      jni.JlObject.fromRef(_matchPattern(string.reference, patterns.reference));

  static final _writeLine = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_writeLine")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private void writeLine(java.util.List<org.apache.pdfbox.text.PDFTextStripper.WordWithTextPositions> line)
  ///
  /// Write a list of string containing a whole line of a document.
  ///@param line a list with the words of the given line
  ///@throws IOException if something went wrong
  void writeLine(jni.JlObject line) => _writeLine(reference, line.reference);

  static final _normalize = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_normalize")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.util.List<org.apache.pdfbox.text.PDFTextStripper.WordWithTextPositions> normalize(java.util.List<org.apache.pdfbox.text.PDFTextStripper.LineItem> line)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Normalize the given list of TextPositions.
  ///@param line list of TextPositions
  ///@return a list of strings, one string for every word
  jni.JlObject normalize(jni.JlObject line) =>
      jni.JlObject.fromRef(_normalize(reference, line.reference));

  static final _handleDirection = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_handleDirection")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String handleDirection(java.lang.String word)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Handles the LTR and RTL direction of the given words. The whole implementation stands and falls with the given
  /// word. If the word is a full line, the results will be the best. If the word contains of single words or
  /// characters, the order of the characters in a word or words in a line may wrong, due to RTL and LTR marks and
  /// characters!
  ///
  /// Based on http://www.nesterovsky-bros.com/weblog/2013/07/28/VisualToLogicalConversionInJava.aspx
  ///@param word The word that shall be processed
  ///@return new word with the correct direction of the containing characters
  jni.JlString handleDirection(jni.JlString word) =>
      jni.JlString.fromRef(_handleDirection(reference, word.reference));

  static final _parseBidiFile =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "org_apache_pdfbox_text_PDFTextStripper_parseBidiFile")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: private static void parseBidiFile(java.io.InputStream inputStream)
  ///
  /// This method parses the bidi file provided as inputstream.
  ///@param inputStream - The bidi file as inputstream
  ///@throws IOException if any line could not be read by the LineNumberReader
  static void parseBidiFile(jni.JlObject inputStream) =>
      _parseBidiFile(inputStream.reference);

  static final _createWord = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_createWord")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.text.PDFTextStripper.WordWithTextPositions createWord(java.lang.String word, java.util.List<org.apache.pdfbox.text.TextPosition> wordPositions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used within \#normalize(List) to create a single WordWithTextPositions entry.
  jni.JlObject createWord(jni.JlString word, jni.JlObject wordPositions) =>
      jni.JlObject.fromRef(
          _createWord(reference, word.reference, wordPositions.reference));

  static final _normalizeWord = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_normalizeWord")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String normalizeWord(java.lang.String word)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Normalize certain Unicode characters. For example, convert the single "fi" ligature to "f" and "i". Also
  /// normalises Arabic and Hebrew presentation forms.
  ///@param word Word to normalize
  ///@return Normalized word
  jni.JlString normalizeWord(jni.JlString word) =>
      jni.JlString.fromRef(_normalizeWord(reference, word.reference));

  static final _normalizeAdd = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "org_apache_pdfbox_text_PDFTextStripper_normalizeAdd")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.StringBuilder normalizeAdd(java.util.List<org.apache.pdfbox.text.PDFTextStripper.WordWithTextPositions> normalized, java.lang.StringBuilder lineBuilder, java.util.List<org.apache.pdfbox.text.TextPosition> wordPositions, org.apache.pdfbox.text.PDFTextStripper.LineItem item)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used within \#normalize(List) to handle a TextPosition.
  ///@return The StringBuilder that must be used when calling this method.
  jni.JlObject normalizeAdd(jni.JlObject normalized, jni.JlObject lineBuilder,
          jni.JlObject wordPositions, jni.JlObject item) =>
      jni.JlObject.fromRef(_normalizeAdd(reference, normalized.reference,
          lineBuilder.reference, wordPositions.reference, item.reference));
}
