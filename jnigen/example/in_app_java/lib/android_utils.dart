// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

// Auto-generated initialization code.

final ffi.Pointer<T> Function<T extends ffi.NativeType>(String sym) jniLookup =
    ProtectedJniExtensions.initGeneratedLibrary("android_utils");

/// from: com.example.in_app_java.AndroidUtils
class AndroidUtils extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  AndroidUtils.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $AndroidUtilsType();
  static final _showToast = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("AndroidUtils__showToast")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void showToast(android.app.Activity mainActivity, java.lang.CharSequence text, int duration)
  static void showToast(
          jni.JObject mainActivity, jni.JObject text, int duration) =>
      _showToast(mainActivity.reference, text.reference, duration).check();
}

class $AndroidUtilsType extends jni.JObjType<AndroidUtils> {
  const $AndroidUtilsType();

  @override
  String get signature => r"Lcom/example/in_app_java/AndroidUtils;";

  @override
  AndroidUtils fromRef(jni.JObjectPtr ref) => AndroidUtils.fromRef(ref);
}

extension $AndroidUtilsArray on jni.JArray<AndroidUtils> {
  AndroidUtils operator [](int index) {
    return (elementType as $AndroidUtilsType)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, AndroidUtils value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}

/// from: android.os.Build
class Build extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  Build.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $BuildType();
  static final _get_BOARD =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__BOARD")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String BOARD
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get BOARD =>
      const jni.JStringType().fromRef(_get_BOARD().object);

  static final _get_BOOTLOADER =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__BOOTLOADER")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String BOOTLOADER
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get BOOTLOADER =>
      const jni.JStringType().fromRef(_get_BOOTLOADER().object);

  static final _get_BRAND =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__BRAND")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String BRAND
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get BRAND =>
      const jni.JStringType().fromRef(_get_BRAND().object);

  static final _get_CPU_ABI =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__CPU_ABI")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String CPU_ABI
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get CPU_ABI =>
      const jni.JStringType().fromRef(_get_CPU_ABI().object);

  static final _get_CPU_ABI2 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__CPU_ABI2")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String CPU_ABI2
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get CPU_ABI2 =>
      const jni.JStringType().fromRef(_get_CPU_ABI2().object);

  static final _get_DEVICE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__DEVICE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String DEVICE
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get DEVICE =>
      const jni.JStringType().fromRef(_get_DEVICE().object);

  static final _get_DISPLAY =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__DISPLAY")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String DISPLAY
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get DISPLAY =>
      const jni.JStringType().fromRef(_get_DISPLAY().object);

  static final _get_FINGERPRINT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__FINGERPRINT")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String FINGERPRINT
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get FINGERPRINT =>
      const jni.JStringType().fromRef(_get_FINGERPRINT().object);

  static final _get_HARDWARE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__HARDWARE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String HARDWARE
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get HARDWARE =>
      const jni.JStringType().fromRef(_get_HARDWARE().object);

  static final _get_HOST =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__HOST")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String HOST
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get HOST =>
      const jni.JStringType().fromRef(_get_HOST().object);

  static final _get_ID =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__ID")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String ID
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get ID =>
      const jni.JStringType().fromRef(_get_ID().object);

  static final _get_MANUFACTURER =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__MANUFACTURER")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String MANUFACTURER
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get MANUFACTURER =>
      const jni.JStringType().fromRef(_get_MANUFACTURER().object);

  static final _get_MODEL =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__MODEL")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String MODEL
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get MODEL =>
      const jni.JStringType().fromRef(_get_MODEL().object);

  static final _get_ODM_SKU =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__ODM_SKU")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String ODM_SKU
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get ODM_SKU =>
      const jni.JStringType().fromRef(_get_ODM_SKU().object);

  static final _get_PRODUCT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__PRODUCT")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String PRODUCT
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get PRODUCT =>
      const jni.JStringType().fromRef(_get_PRODUCT().object);

  static final _get_RADIO =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__RADIO")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String RADIO
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get RADIO =>
      const jni.JStringType().fromRef(_get_RADIO().object);

  static final _get_SERIAL =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SERIAL")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String SERIAL
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get SERIAL =>
      const jni.JStringType().fromRef(_get_SERIAL().object);

  static final _get_SKU =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__SKU")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String SKU
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get SKU =>
      const jni.JStringType().fromRef(_get_SKU().object);

  static final _get_SOC_MANUFACTURER =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SOC_MANUFACTURER")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String SOC_MANUFACTURER
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get SOC_MANUFACTURER =>
      const jni.JStringType().fromRef(_get_SOC_MANUFACTURER().object);

  static final _get_SOC_MODEL =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SOC_MODEL")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String SOC_MODEL
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get SOC_MODEL =>
      const jni.JStringType().fromRef(_get_SOC_MODEL().object);

  static final _get_SUPPORTED_32_BIT_ABIS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SUPPORTED_32_BIT_ABIS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String[] SUPPORTED_32_BIT_ABIS
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<jni.JString> get SUPPORTED_32_BIT_ABIS =>
      const jni.JArrayType(jni.JStringType())
          .fromRef(_get_SUPPORTED_32_BIT_ABIS().object);

  static final _get_SUPPORTED_64_BIT_ABIS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SUPPORTED_64_BIT_ABIS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String[] SUPPORTED_64_BIT_ABIS
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<jni.JString> get SUPPORTED_64_BIT_ABIS =>
      const jni.JArrayType(jni.JStringType())
          .fromRef(_get_SUPPORTED_64_BIT_ABIS().object);

  static final _get_SUPPORTED_ABIS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SUPPORTED_ABIS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String[] SUPPORTED_ABIS
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<jni.JString> get SUPPORTED_ABIS =>
      const jni.JArrayType(jni.JStringType())
          .fromRef(_get_SUPPORTED_ABIS().object);

  static final _get_TAGS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__TAGS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String TAGS
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get TAGS =>
      const jni.JStringType().fromRef(_get_TAGS().object);

  static final _get_TIME =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__TIME")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final long TIME
  static int get TIME => _get_TIME().long;

  static final _get_TYPE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__TYPE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String TYPE
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get TYPE =>
      const jni.JStringType().fromRef(_get_TYPE().object);

  /// from: static public final java.lang.String UNKNOWN
  static const UNKNOWN = r"""unknown""";

  static final _get_USER =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__USER")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String USER
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get USER =>
      const jni.JStringType().fromRef(_get_USER().object);

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Build__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Build() : super.fromRef(_ctor().object);

  static final _getSerial =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Build__getSerial")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.lang.String getSerial()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString getSerial() =>
      const jni.JStringType().fromRef(_getSerial().object);

  static final _getFingerprintedPartitions =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Build__getFingerprintedPartitions")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.List getFingerprintedPartitions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject getFingerprintedPartitions() =>
      const jni.JObjectType().fromRef(_getFingerprintedPartitions().object);

  static final _getRadioVersion =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Build__getRadioVersion")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.lang.String getRadioVersion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString getRadioVersion() =>
      const jni.JStringType().fromRef(_getRadioVersion().object);
}

class $BuildType extends jni.JObjType<Build> {
  const $BuildType();

  @override
  String get signature => r"Landroid/os/Build;";

  @override
  Build fromRef(jni.JObjectPtr ref) => Build.fromRef(ref);
}

extension $BuildArray on jni.JArray<Build> {
  Build operator [](int index) {
    return (elementType as $BuildType)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, Build value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}

/// from: java.util.HashMap
class HashMap<K extends jni.JObject, V extends jni.JObject>
    extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type($K, $V);

  final jni.JObjType<K> $K;
  final jni.JObjType<V> $V;

  HashMap.fromRef(
    this.$K,
    this.$V,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $HashMapType<K, V> type<K extends jni.JObject, V extends jni.JObject>(
    jni.JObjType<K> $K,
    jni.JObjType<V> $V,
  ) {
    return $HashMapType(
      $K,
      $V,
    );
  }

  static final _ctor = jniLookup<
              ffi.NativeFunction<jni.JniResult Function(ffi.Int32, ffi.Float)>>(
          "HashMap__ctor")
      .asFunction<jni.JniResult Function(int, double)>();

  /// from: public void <init>(int i, float f)
  /// The returned object must be deleted after use, by calling the `delete` method.
  HashMap(this.$K, this.$V, int i, double f)
      : super.fromRef(_ctor(i, f).object);

  static final _ctor1 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "HashMap__ctor1")
          .asFunction<jni.JniResult Function(int)>();

  /// from: public void <init>(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  HashMap.ctor1(this.$K, this.$V, int i) : super.fromRef(_ctor1(i).object);

  static final _ctor2 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("HashMap__ctor2")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  HashMap.ctor2(this.$K, this.$V) : super.fromRef(_ctor2().object);

  static final _ctor3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("HashMap__ctor3")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.util.Map map)
  /// The returned object must be deleted after use, by calling the `delete` method.
  HashMap.ctor3(this.$K, this.$V, jni.JObject map)
      : super.fromRef(_ctor3(map.reference).object);

  static final _size = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("HashMap__size")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int size()
  int size() => _size(reference).integer;

  static final _isEmpty = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("HashMap__isEmpty")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEmpty()
  bool isEmpty() => _isEmpty(reference).boolean;

  static final _get0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__get0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public V get(java.lang.Object object)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V get0(jni.JObject object) =>
      $V.fromRef(_get0(reference, object.reference).object);

  static final _containsKey = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__containsKey")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean containsKey(java.lang.Object object)
  bool containsKey(jni.JObject object) =>
      _containsKey(reference, object.reference).boolean;

  static final _put = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__put")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public V put(K object, V object1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V put(K object, V object1) =>
      $V.fromRef(_put(reference, object.reference, object1.reference).object);

  static final _putAll = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__putAll")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void putAll(java.util.Map map)
  void putAll(jni.JObject map) => _putAll(reference, map.reference).check();

  static final _remove = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__remove")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public V remove(java.lang.Object object)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V remove(jni.JObject object) =>
      $V.fromRef(_remove(reference, object.reference).object);

  static final _clear = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("HashMap__clear")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clear()
  void clear() => _clear(reference).check();

  static final _containsValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__containsValue")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean containsValue(java.lang.Object object)
  bool containsValue(jni.JObject object) =>
      _containsValue(reference, object.reference).boolean;

  static final _keySet = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("HashMap__keySet")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set keySet()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject keySet() =>
      const jni.JObjectType().fromRef(_keySet(reference).object);

  static final _values = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("HashMap__values")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Collection values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject values() =>
      const jni.JObjectType().fromRef(_values(reference).object);

  static final _entrySet = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("HashMap__entrySet")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set entrySet()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject entrySet() =>
      const jni.JObjectType().fromRef(_entrySet(reference).object);

  static final _getOrDefault = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__getOrDefault")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public V getOrDefault(java.lang.Object object, V object1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V getOrDefault(jni.JObject object, V object1) => $V.fromRef(
      _getOrDefault(reference, object.reference, object1.reference).object);

  static final _putIfAbsent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__putIfAbsent")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public V putIfAbsent(K object, V object1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V putIfAbsent(K object, V object1) => $V.fromRef(
      _putIfAbsent(reference, object.reference, object1.reference).object);

  static final _remove1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__remove1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean remove(java.lang.Object object, java.lang.Object object1)
  bool remove1(jni.JObject object, jni.JObject object1) =>
      _remove1(reference, object.reference, object1.reference).boolean;

  static final _replace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__replace")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean replace(K object, V object1, V object2)
  bool replace(K object, V object1, V object2) => _replace(
          reference, object.reference, object1.reference, object2.reference)
      .boolean;

  static final _replace1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__replace1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public V replace(K object, V object1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V replace1(K object, V object1) => $V.fromRef(
      _replace1(reference, object.reference, object1.reference).object);

  static final _computeIfAbsent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__computeIfAbsent")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public V computeIfAbsent(K object, java.util.function.Function function)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V computeIfAbsent(K object, jni.JObject function) => $V.fromRef(
      _computeIfAbsent(reference, object.reference, function.reference).object);

  static final _computeIfPresent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__computeIfPresent")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public V computeIfPresent(K object, java.util.function.BiFunction biFunction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V computeIfPresent(K object, jni.JObject biFunction) => $V.fromRef(
      _computeIfPresent(reference, object.reference, biFunction.reference)
          .object);

  static final _compute = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__compute")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public V compute(K object, java.util.function.BiFunction biFunction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V compute(K object, jni.JObject biFunction) => $V.fromRef(
      _compute(reference, object.reference, biFunction.reference).object);

  static final _merge = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__merge")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public V merge(K object, V object1, java.util.function.BiFunction biFunction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V merge(K object, V object1, jni.JObject biFunction) => $V.fromRef(_merge(
          reference, object.reference, object1.reference, biFunction.reference)
      .object);

  static final _forEach = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__forEach")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void forEach(java.util.function.BiConsumer biConsumer)
  void forEach(jni.JObject biConsumer) =>
      _forEach(reference, biConsumer.reference).check();

  static final _replaceAll = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("HashMap__replaceAll")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void replaceAll(java.util.function.BiFunction biFunction)
  void replaceAll(jni.JObject biFunction) =>
      _replaceAll(reference, biFunction.reference).check();

  static final _clone = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("HashMap__clone")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject clone() =>
      const jni.JObjectType().fromRef(_clone(reference).object);
}

class $HashMapType<K extends jni.JObject, V extends jni.JObject>
    extends jni.JObjType<HashMap<K, V>> {
  final jni.JObjType<K> $K;
  final jni.JObjType<V> $V;

  const $HashMapType(
    this.$K,
    this.$V,
  );

  @override
  String get signature => r"Ljava/util/HashMap;";

  @override
  HashMap<K, V> fromRef(jni.JObjectPtr ref) => HashMap.fromRef($K, $V, ref);
}

extension $HashMapArray<K extends jni.JObject, V extends jni.JObject>
    on jni.JArray<HashMap<K, V>> {
  HashMap<K, V> operator [](int index) {
    return (elementType as $HashMapType<K, V>)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, HashMap<K, V> value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}
