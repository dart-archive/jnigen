// Generated from Apache PDFBox library which is licensed under the Apache License 2.0.
// The following copyright from the original authors applies.
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: file_names
// ignore_for_file: unused_import
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../pdmodel/PDDocument.dart" as pddocument_;
import "../../../../_init.dart" show jniLookup;

/// from: org.apache.pdfbox.text.PDFTextStripper
///
/// This class will take a pdf document and strip out all of the text and ignore the formatting and such. Please note; it
/// is up to clients of this class to verify that a specific user has the correct permissions to extract text from the
/// PDF document.
///
/// The basic flow of this process is that we get a document and use a series of processXXX() functions that work on
/// smaller and smaller chunks of the page. Eventually, we fully process each page and then print it.
///@author Ben Litchfield
class PDFTextStripper extends jni.JniObject {
  PDFTextStripper.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_defaultIndentThreshold =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_PDFTextStripper__defaultIndentThreshold")
          .asFunction<jni.JniResult Function()>();

  /// from: private static float defaultIndentThreshold
  static double get defaultIndentThreshold =>
      _get_defaultIndentThreshold().float;
  static final _set_defaultIndentThreshold =
      jniLookup<ffi.NativeFunction<jni.JThrowable Function(ffi.Float)>>(
              "set_PDFTextStripper__defaultIndentThreshold")
          .asFunction<jni.JThrowable Function(double)>();

  /// from: private static float defaultIndentThreshold
  static set defaultIndentThreshold(double value) =>
      _set_defaultIndentThreshold(value);

  static final _get_defaultDropThreshold =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_PDFTextStripper__defaultDropThreshold")
          .asFunction<jni.JniResult Function()>();

  /// from: private static float defaultDropThreshold
  static double get defaultDropThreshold => _get_defaultDropThreshold().float;
  static final _set_defaultDropThreshold =
      jniLookup<ffi.NativeFunction<jni.JThrowable Function(ffi.Float)>>(
              "set_PDFTextStripper__defaultDropThreshold")
          .asFunction<jni.JThrowable Function(double)>();

  /// from: private static float defaultDropThreshold
  static set defaultDropThreshold(double value) =>
      _set_defaultDropThreshold(value);

  static final _get_LOG =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_PDFTextStripper__LOG")
          .asFunction<jni.JniResult Function()>();

  /// from: private static final org.apache.commons.logging.Log LOG
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject get LOG => jni.JniObject.fromRef(_get_LOG().object);

  static final _get_LINE_SEPARATOR = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__LINE_SEPARATOR")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: protected final java.lang.String LINE_SEPARATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The platform's line separator.
  jni.JniString get LINE_SEPARATOR =>
      jni.JniString.fromRef(_get_LINE_SEPARATOR(reference).object);

  static final _get_lineSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__lineSeparator")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private java.lang.String lineSeparator
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get lineSeparator =>
      jni.JniString.fromRef(_get_lineSeparator(reference).object);
  static final _set_lineSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__lineSeparator")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String lineSeparator
  /// The returned object must be deleted after use, by calling the `delete` method.
  set lineSeparator(jni.JniString value) =>
      _set_lineSeparator(reference, value.reference);

  static final _get_wordSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__wordSeparator")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private java.lang.String wordSeparator
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get wordSeparator =>
      jni.JniString.fromRef(_get_wordSeparator(reference).object);
  static final _set_wordSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__wordSeparator")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String wordSeparator
  /// The returned object must be deleted after use, by calling the `delete` method.
  set wordSeparator(jni.JniString value) =>
      _set_wordSeparator(reference, value.reference);

  static final _get_paragraphStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__paragraphStart")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private java.lang.String paragraphStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get paragraphStart =>
      jni.JniString.fromRef(_get_paragraphStart(reference).object);
  static final _set_paragraphStart = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_PDFTextStripper__paragraphStart")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String paragraphStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  set paragraphStart(jni.JniString value) =>
      _set_paragraphStart(reference, value.reference);

  static final _get_paragraphEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__paragraphEnd")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private java.lang.String paragraphEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get paragraphEnd =>
      jni.JniString.fromRef(_get_paragraphEnd(reference).object);
  static final _set_paragraphEnd = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__paragraphEnd")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String paragraphEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  set paragraphEnd(jni.JniString value) =>
      _set_paragraphEnd(reference, value.reference);

  static final _get_pageStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__pageStart")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private java.lang.String pageStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get pageStart =>
      jni.JniString.fromRef(_get_pageStart(reference).object);
  static final _set_pageStart = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__pageStart")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String pageStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  set pageStart(jni.JniString value) =>
      _set_pageStart(reference, value.reference);

  static final _get_pageEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__pageEnd")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private java.lang.String pageEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get pageEnd =>
      jni.JniString.fromRef(_get_pageEnd(reference).object);
  static final _set_pageEnd = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__pageEnd")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String pageEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  set pageEnd(jni.JniString value) => _set_pageEnd(reference, value.reference);

  static final _get_articleStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__articleStart")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private java.lang.String articleStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get articleStart =>
      jni.JniString.fromRef(_get_articleStart(reference).object);
  static final _set_articleStart = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__articleStart")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String articleStart
  /// The returned object must be deleted after use, by calling the `delete` method.
  set articleStart(jni.JniString value) =>
      _set_articleStart(reference, value.reference);

  static final _get_articleEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__articleEnd")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private java.lang.String articleEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get articleEnd =>
      jni.JniString.fromRef(_get_articleEnd(reference).object);
  static final _set_articleEnd = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__articleEnd")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String articleEnd
  /// The returned object must be deleted after use, by calling the `delete` method.
  set articleEnd(jni.JniString value) =>
      _set_articleEnd(reference, value.reference);

  static final _get_currentPageNo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__currentPageNo")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private int currentPageNo
  int get currentPageNo => _get_currentPageNo(reference).integer;
  static final _set_currentPageNo = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_PDFTextStripper__currentPageNo")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: private int currentPageNo
  set currentPageNo(int value) => _set_currentPageNo(reference, value);

  static final _get_startPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__startPage")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private int startPage
  int get startPage => _get_startPage(reference).integer;
  static final _set_startPage = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_PDFTextStripper__startPage")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: private int startPage
  set startPage(int value) => _set_startPage(reference, value);

  static final _get_endPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__endPage")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private int endPage
  int get endPage => _get_endPage(reference).integer;
  static final _set_endPage = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_PDFTextStripper__endPage")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: private int endPage
  set endPage(int value) => _set_endPage(reference, value);

  static final _get_startBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__startBookmark")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem startBookmark
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get startBookmark =>
      jni.JniObject.fromRef(_get_startBookmark(reference).object);
  static final _set_startBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__startBookmark")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem startBookmark
  /// The returned object must be deleted after use, by calling the `delete` method.
  set startBookmark(jni.JniObject value) =>
      _set_startBookmark(reference, value.reference);

  static final _get_startBookmarkPageNumber = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__startBookmarkPageNumber")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private int startBookmarkPageNumber
  int get startBookmarkPageNumber =>
      _get_startBookmarkPageNumber(reference).integer;
  static final _set_startBookmarkPageNumber = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_PDFTextStripper__startBookmarkPageNumber")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: private int startBookmarkPageNumber
  set startBookmarkPageNumber(int value) =>
      _set_startBookmarkPageNumber(reference, value);

  static final _get_endBookmarkPageNumber = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__endBookmarkPageNumber")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private int endBookmarkPageNumber
  int get endBookmarkPageNumber =>
      _get_endBookmarkPageNumber(reference).integer;
  static final _set_endBookmarkPageNumber = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_PDFTextStripper__endBookmarkPageNumber")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: private int endBookmarkPageNumber
  set endBookmarkPageNumber(int value) =>
      _set_endBookmarkPageNumber(reference, value);

  static final _get_endBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__endBookmark")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem endBookmark
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get endBookmark =>
      jni.JniObject.fromRef(_get_endBookmark(reference).object);
  static final _set_endBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__endBookmark")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem endBookmark
  /// The returned object must be deleted after use, by calling the `delete` method.
  set endBookmark(jni.JniObject value) =>
      _set_endBookmark(reference, value.reference);

  static final _get_suppressDuplicateOverlappingText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__suppressDuplicateOverlappingText")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private boolean suppressDuplicateOverlappingText
  bool get suppressDuplicateOverlappingText =>
      _get_suppressDuplicateOverlappingText(reference).boolean;
  static final _set_suppressDuplicateOverlappingText = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Uint8)>>(
          "set_PDFTextStripper__suppressDuplicateOverlappingText")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: private boolean suppressDuplicateOverlappingText
  set suppressDuplicateOverlappingText(bool value) =>
      _set_suppressDuplicateOverlappingText(reference, value ? 1 : 0);

  static final _get_shouldSeparateByBeads = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__shouldSeparateByBeads")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private boolean shouldSeparateByBeads
  bool get shouldSeparateByBeads =>
      _get_shouldSeparateByBeads(reference).boolean;
  static final _set_shouldSeparateByBeads = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Uint8)>>("set_PDFTextStripper__shouldSeparateByBeads")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: private boolean shouldSeparateByBeads
  set shouldSeparateByBeads(bool value) =>
      _set_shouldSeparateByBeads(reference, value ? 1 : 0);

  static final _get_sortByPosition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__sortByPosition")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private boolean sortByPosition
  bool get sortByPosition => _get_sortByPosition(reference).boolean;
  static final _set_sortByPosition = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Uint8)>>("set_PDFTextStripper__sortByPosition")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: private boolean sortByPosition
  set sortByPosition(bool value) =>
      _set_sortByPosition(reference, value ? 1 : 0);

  static final _get_addMoreFormatting = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__addMoreFormatting")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private boolean addMoreFormatting
  bool get addMoreFormatting => _get_addMoreFormatting(reference).boolean;
  static final _set_addMoreFormatting = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Uint8)>>("set_PDFTextStripper__addMoreFormatting")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: private boolean addMoreFormatting
  set addMoreFormatting(bool value) =>
      _set_addMoreFormatting(reference, value ? 1 : 0);

  static final _get_indentThreshold = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__indentThreshold")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private float indentThreshold
  double get indentThreshold => _get_indentThreshold(reference).float;
  static final _set_indentThreshold = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Float)>>("set_PDFTextStripper__indentThreshold")
      .asFunction<jni.JThrowable Function(jni.JObject, double)>();

  /// from: private float indentThreshold
  set indentThreshold(double value) => _set_indentThreshold(reference, value);

  static final _get_dropThreshold = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__dropThreshold")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private float dropThreshold
  double get dropThreshold => _get_dropThreshold(reference).float;
  static final _set_dropThreshold = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Float)>>("set_PDFTextStripper__dropThreshold")
      .asFunction<jni.JThrowable Function(jni.JObject, double)>();

  /// from: private float dropThreshold
  set dropThreshold(double value) => _set_dropThreshold(reference, value);

  static final _get_spacingTolerance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__spacingTolerance")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private float spacingTolerance
  double get spacingTolerance => _get_spacingTolerance(reference).float;
  static final _set_spacingTolerance = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Float)>>("set_PDFTextStripper__spacingTolerance")
      .asFunction<jni.JThrowable Function(jni.JObject, double)>();

  /// from: private float spacingTolerance
  set spacingTolerance(double value) => _set_spacingTolerance(reference, value);

  static final _get_averageCharTolerance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__averageCharTolerance")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private float averageCharTolerance
  double get averageCharTolerance => _get_averageCharTolerance(reference).float;
  static final _set_averageCharTolerance = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Float)>>("set_PDFTextStripper__averageCharTolerance")
      .asFunction<jni.JThrowable Function(jni.JObject, double)>();

  /// from: private float averageCharTolerance
  set averageCharTolerance(double value) =>
      _set_averageCharTolerance(reference, value);

  static final _get_beadRectangles = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__beadRectangles")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private java.util.List<org.apache.pdfbox.pdmodel.common.PDRectangle> beadRectangles
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get beadRectangles =>
      jni.JniObject.fromRef(_get_beadRectangles(reference).object);
  static final _set_beadRectangles = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_PDFTextStripper__beadRectangles")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private java.util.List<org.apache.pdfbox.pdmodel.common.PDRectangle> beadRectangles
  /// The returned object must be deleted after use, by calling the `delete` method.
  set beadRectangles(jni.JniObject value) =>
      _set_beadRectangles(reference, value.reference);

  static final _get_charactersByArticle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__charactersByArticle")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: protected java.util.ArrayList<java.util.List<org.apache.pdfbox.text.TextPosition>> charactersByArticle
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The charactersByArticle is used to extract text by article divisions. For example a PDF that has two columns like
  /// a newspaper, we want to extract the first column and then the second column. In this example the PDF would have 2
  /// beads(or articles), one for each column. The size of the charactersByArticle would be 5, because not all text on
  /// the screen will fall into one of the articles. The five divisions are shown below
  ///
  /// Text before first article
  /// first article text
  /// text between first article and second article
  /// second article text
  /// text after second article
  ///
  /// Most PDFs won't have any beads, so charactersByArticle will contain a single entry.
  jni.JniObject get charactersByArticle =>
      jni.JniObject.fromRef(_get_charactersByArticle(reference).object);
  static final _set_charactersByArticle = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_PDFTextStripper__charactersByArticle")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: protected java.util.ArrayList<java.util.List<org.apache.pdfbox.text.TextPosition>> charactersByArticle
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The charactersByArticle is used to extract text by article divisions. For example a PDF that has two columns like
  /// a newspaper, we want to extract the first column and then the second column. In this example the PDF would have 2
  /// beads(or articles), one for each column. The size of the charactersByArticle would be 5, because not all text on
  /// the screen will fall into one of the articles. The five divisions are shown below
  ///
  /// Text before first article
  /// first article text
  /// text between first article and second article
  /// second article text
  /// text after second article
  ///
  /// Most PDFs won't have any beads, so charactersByArticle will contain a single entry.
  set charactersByArticle(jni.JniObject value) =>
      _set_charactersByArticle(reference, value.reference);

  static final _get_characterListMapping = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__characterListMapping")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private java.util.Map<java.lang.String,java.util.TreeMap<java.lang.Float,java.util.TreeSet<java.lang.Float>>> characterListMapping
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get characterListMapping =>
      jni.JniObject.fromRef(_get_characterListMapping(reference).object);
  static final _set_characterListMapping = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_PDFTextStripper__characterListMapping")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private java.util.Map<java.lang.String,java.util.TreeMap<java.lang.Float,java.util.TreeSet<java.lang.Float>>> characterListMapping
  /// The returned object must be deleted after use, by calling the `delete` method.
  set characterListMapping(jni.JniObject value) =>
      _set_characterListMapping(reference, value.reference);

  static final _get_document = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__document")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: protected org.apache.pdfbox.pdmodel.PDDocument document
  /// The returned object must be deleted after use, by calling the `delete` method.
  pddocument_.PDDocument get document =>
      pddocument_.PDDocument.fromRef(_get_document(reference).object);
  static final _set_document = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__document")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: protected org.apache.pdfbox.pdmodel.PDDocument document
  /// The returned object must be deleted after use, by calling the `delete` method.
  set document(pddocument_.PDDocument value) =>
      _set_document(reference, value.reference);

  static final _get_output = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__output")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: protected java.io.Writer output
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get output =>
      jni.JniObject.fromRef(_get_output(reference).object);
  static final _set_output = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__output")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: protected java.io.Writer output
  /// The returned object must be deleted after use, by calling the `delete` method.
  set output(jni.JniObject value) => _set_output(reference, value.reference);

  static final _get_inParagraph = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__inParagraph")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private boolean inParagraph
  ///
  /// True if we started a paragraph but haven't ended it yet.
  bool get inParagraph => _get_inParagraph(reference).boolean;
  static final _set_inParagraph = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Uint8)>>("set_PDFTextStripper__inParagraph")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: private boolean inParagraph
  ///
  /// True if we started a paragraph but haven't ended it yet.
  set inParagraph(bool value) => _set_inParagraph(reference, value ? 1 : 0);

  /// from: private static final float END_OF_LAST_TEXT_X_RESET_VALUE
  static const END_OF_LAST_TEXT_X_RESET_VALUE = -1.0;

  /// from: private static final float MAX_Y_FOR_LINE_RESET_VALUE
  static const MAX_Y_FOR_LINE_RESET_VALUE = -3.4028235e+38;

  /// from: private static final float EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE
  static const EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE = -3.4028235e+38;

  /// from: private static final float MAX_HEIGHT_FOR_LINE_RESET_VALUE
  static const MAX_HEIGHT_FOR_LINE_RESET_VALUE = -1.0;

  /// from: private static final float MIN_Y_TOP_FOR_LINE_RESET_VALUE
  static const MIN_Y_TOP_FOR_LINE_RESET_VALUE = 3.4028235e+38;

  /// from: private static final float LAST_WORD_SPACING_RESET_VALUE
  static const LAST_WORD_SPACING_RESET_VALUE = -1.0;

  static final _get_LIST_ITEM_EXPRESSIONS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_PDFTextStripper__LIST_ITEM_EXPRESSIONS")
          .asFunction<jni.JniResult Function()>();

  /// from: private static final java.lang.String[] LIST_ITEM_EXPRESSIONS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// a list of regular expressions that match commonly used list item formats, i.e. bullets, numbers, letters, Roman
  /// numerals, etc. Not meant to be comprehensive.
  static jni.JniObject get LIST_ITEM_EXPRESSIONS =>
      jni.JniObject.fromRef(_get_LIST_ITEM_EXPRESSIONS().object);

  static final _get_listOfPatterns = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_PDFTextStripper__listOfPatterns")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: private java.util.List<java.util.regex.Pattern> listOfPatterns
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get listOfPatterns =>
      jni.JniObject.fromRef(_get_listOfPatterns(reference).object);
  static final _set_listOfPatterns = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_PDFTextStripper__listOfPatterns")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: private java.util.List<java.util.regex.Pattern> listOfPatterns
  /// The returned object must be deleted after use, by calling the `delete` method.
  set listOfPatterns(jni.JniObject value) =>
      _set_listOfPatterns(reference, value.reference);

  static final _get_MIRRORING_CHAR_MAP =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_PDFTextStripper__MIRRORING_CHAR_MAP")
          .asFunction<jni.JniResult Function()>();

  /// from: private static java.util.Map<java.lang.Character,java.lang.Character> MIRRORING_CHAR_MAP
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject get MIRRORING_CHAR_MAP =>
      jni.JniObject.fromRef(_get_MIRRORING_CHAR_MAP().object);
  static final _set_MIRRORING_CHAR_MAP = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(ffi.Pointer<ffi.Void>)>>(
          "set_PDFTextStripper__MIRRORING_CHAR_MAP")
      .asFunction<jni.JThrowable Function(ffi.Pointer<ffi.Void>)>();

  /// from: private static java.util.Map<java.lang.Character,java.lang.Character> MIRRORING_CHAR_MAP
  /// The returned object must be deleted after use, by calling the `delete` method.
  static set MIRRORING_CHAR_MAP(jni.JniObject value) =>
      _set_MIRRORING_CHAR_MAP(value.reference);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "PDFTextStripper__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Instantiate a new PDFTextStripper object.
  ///@throws IOException If there is an error loading the properties.
  PDFTextStripper() : super.fromRef(_ctor().object);

  static final _getText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getText(org.apache.pdfbox.pdmodel.PDDocument doc)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will return the text of a document. See writeText. <br>
  /// NOTE: The document must not be encrypted when coming into this method.
  ///
  /// IMPORTANT: By default, text extraction is done in the same sequence as the text in the PDF page content stream.
  /// PDF is a graphic format, not a text format, and unlike HTML, it has no requirements that text one on page
  /// be rendered in a certain order. The order is the one that was determined by the software that created the
  /// PDF. To get text sorted from left to right and top to botton, use \#setSortByPosition(boolean).
  ///@param doc The document to get the text from.
  ///@return The text of the PDF document.
  ///@throws IOException if the doc state is invalid or it is encrypted.
  jni.JniString getText(pddocument_.PDDocument doc) =>
      jni.JniString.fromRef(_getText(reference, doc.reference).object);

  static final _resetEngine = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__resetEngine")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: private void resetEngine()
  void resetEngine() => _resetEngine(reference).check();

  static final _writeText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writeText")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void writeText(org.apache.pdfbox.pdmodel.PDDocument doc, java.io.Writer outputStream)
  ///
  /// This will take a PDDocument and write the text of that document to the print writer.
  ///@param doc The document to get the data from.
  ///@param outputStream The location to put the text.
  ///@throws IOException If the doc is in an invalid state.
  void writeText(pddocument_.PDDocument doc, jni.JniObject outputStream) =>
      _writeText(reference, doc.reference, outputStream.reference).check();

  static final _processPages = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__processPages")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void processPages(org.apache.pdfbox.pdmodel.PDPageTree pages)
  ///
  /// This will process all of the pages and the text that is in them.
  ///@param pages The pages object in the document.
  ///@throws IOException If there is an error parsing the text.
  void processPages(jni.JniObject pages) =>
      _processPages(reference, pages.reference).check();

  static final _startDocument = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__startDocument")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void startDocument(org.apache.pdfbox.pdmodel.PDDocument document)
  ///
  /// This method is available for subclasses of this class. It will be called before processing of the document start.
  ///@param document The PDF document that is being processed.
  ///@throws IOException If an IO error occurs.
  void startDocument(pddocument_.PDDocument document) =>
      _startDocument(reference, document.reference).check();

  static final _endDocument = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__endDocument")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void endDocument(org.apache.pdfbox.pdmodel.PDDocument document)
  ///
  /// This method is available for subclasses of this class. It will be called after processing of the document
  /// finishes.
  ///@param document The PDF document that is being processed.
  ///@throws IOException If an IO error occurs.
  void endDocument(pddocument_.PDDocument document) =>
      _endDocument(reference, document.reference).check();

  static final _processPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__processPage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void processPage(org.apache.pdfbox.pdmodel.PDPage page)
  ///
  /// This will process the contents of a page.
  ///@param page The page to process.
  ///@throws IOException If there is an error processing the page.
  void processPage(jni.JniObject page) =>
      _processPage(reference, page.reference).check();

  static final _fillBeadRectangles = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__fillBeadRectangles")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private void fillBeadRectangles(org.apache.pdfbox.pdmodel.PDPage page)
  void fillBeadRectangles(jni.JniObject page) =>
      _fillBeadRectangles(reference, page.reference).check();

  static final _startArticle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__startArticle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void startArticle()
  ///
  /// Start a new article, which is typically defined as a column on a single page (also referred to as a bead). This
  /// assumes that the primary direction of text is left to right. Default implementation is to do nothing. Subclasses
  /// may provide additional information.
  ///@throws IOException If there is any error writing to the stream.
  void startArticle() => _startArticle(reference).check();

  static final _startArticle1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("PDFTextStripper__startArticle1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected void startArticle(boolean isLTR)
  ///
  /// Start a new article, which is typically defined as a column on a single page (also referred to as a bead).
  /// Default implementation is to do nothing. Subclasses may provide additional information.
  ///@param isLTR true if primary direction of text is left to right.
  ///@throws IOException If there is any error writing to the stream.
  void startArticle1(bool isLTR) =>
      _startArticle1(reference, isLTR ? 1 : 0).check();

  static final _endArticle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__endArticle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void endArticle()
  ///
  /// End an article. Default implementation is to do nothing. Subclasses may provide additional information.
  ///@throws IOException If there is any error writing to the stream.
  void endArticle() => _endArticle(reference).check();

  static final _startPage1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__startPage1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void startPage(org.apache.pdfbox.pdmodel.PDPage page)
  ///
  /// Start a new page. Default implementation is to do nothing. Subclasses may provide additional information.
  ///@param page The page we are about to process.
  ///@throws IOException If there is any error writing to the stream.
  void startPage1(jni.JniObject page) =>
      _startPage1(reference, page.reference).check();

  static final _endPage1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__endPage1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void endPage(org.apache.pdfbox.pdmodel.PDPage page)
  ///
  /// End a page. Default implementation is to do nothing. Subclasses may provide additional information.
  ///@param page The page we are about to process.
  ///@throws IOException If there is any error writing to the stream.
  void endPage1(jni.JniObject page) =>
      _endPage1(reference, page.reference).check();

  static final _writePage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writePage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writePage()
  ///
  /// This will print the text of the processed page to "output". It will estimate, based on the coordinates of the
  /// text, where newlines and word spacings should be placed. The text will be sorted only if that feature was
  /// enabled.
  ///@throws IOException If there is an error writing the text.
  void writePage() => _writePage(reference).check();

  static final _overlap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Float,
                  ffi.Float, ffi.Float, ffi.Float)>>("PDFTextStripper__overlap")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, double, double, double, double)>();

  /// from: private boolean overlap(float y1, float height1, float y2, float height2)
  bool overlap(double y1, double height1, double y2, double height2) =>
      _overlap(reference, y1, height1, y2, height2).boolean;

  static final _writeLineSeparator = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__writeLineSeparator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeLineSeparator()
  ///
  /// Write the line separator value to the output stream.
  ///@throws IOException If there is a problem writing out the line separator to the document.
  void writeLineSeparator() => _writeLineSeparator(reference).check();

  static final _writeWordSeparator = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__writeWordSeparator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeWordSeparator()
  ///
  /// Write the word separator value to the output stream.
  ///@throws IOException If there is a problem writing out the word separator to the document.
  void writeWordSeparator() => _writeWordSeparator(reference).check();

  static final _writeCharacters = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writeCharacters")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeCharacters(org.apache.pdfbox.text.TextPosition text)
  ///
  /// Write the string in TextPosition to the output stream.
  ///@param text The text to write to the stream.
  ///@throws IOException If there is an error when writing the text.
  void writeCharacters(jni.JniObject text) =>
      _writeCharacters(reference, text.reference).check();

  static final _writeString = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writeString")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeString(java.lang.String text, java.util.List<org.apache.pdfbox.text.TextPosition> textPositions)
  ///
  /// Write a Java string to the output stream. The default implementation will ignore the <code>textPositions</code>
  /// and just calls \#writeString(String).
  ///@param text The text to write to the stream.
  ///@param textPositions The TextPositions belonging to the text.
  ///@throws IOException If there is an error when writing the text.
  void writeString(jni.JniString text, jni.JniObject textPositions) =>
      _writeString(reference, text.reference, textPositions.reference).check();

  static final _writeString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writeString1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeString(java.lang.String text)
  ///
  /// Write a Java string to the output stream.
  ///@param text The text to write to the stream.
  ///@throws IOException If there is an error when writing the text.
  void writeString1(jni.JniString text) =>
      _writeString1(reference, text.reference).check();

  static final _within = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Float,
                  ffi.Float, ffi.Float)>>("PDFTextStripper__within")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, double, double, double)>();

  /// from: private boolean within(float first, float second, float variance)
  ///
  /// This will determine of two floating point numbers are within a specified variance.
  ///@param first The first number to compare to.
  ///@param second The second number to compare to.
  ///@param variance The allowed variance.
  bool within(double first, double second, double variance) =>
      _within(reference, first, second, variance).boolean;

  static final _processTextPosition = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__processTextPosition")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void processTextPosition(org.apache.pdfbox.text.TextPosition text)
  ///
  /// This will process a TextPosition object and add the text to the list of characters on a page. It takes care of
  /// overlapping text.
  ///@param text The text to process.
  void processTextPosition(jni.JniObject text) =>
      _processTextPosition(reference, text.reference).check();

  static final _getStartPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getStartPage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getStartPage()
  ///
  /// This is the page that the text extraction will start on. The pages start at page 1. For example in a 5 page PDF
  /// document, if the start page is 1 then all pages will be extracted. If the start page is 4 then pages 4 and 5 will
  /// be extracted. The default value is 1.
  ///@return Value of property startPage.
  int getStartPage() => _getStartPage(reference).integer;

  static final _setStartPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PDFTextStripper__setStartPage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setStartPage(int startPageValue)
  ///
  /// This will set the first page to be extracted by this class.
  ///@param startPageValue New value of 1-based startPage property.
  void setStartPage(int startPageValue) =>
      _setStartPage(reference, startPageValue).check();

  static final _getEndPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getEndPage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getEndPage()
  ///
  /// This will get the last page that will be extracted. This is inclusive, for example if a 5 page PDF an endPage
  /// value of 5 would extract the entire document, an end page of 2 would extract pages 1 and 2. This defaults to
  /// Integer.MAX_VALUE such that all pages of the pdf will be extracted.
  ///@return Value of property endPage.
  int getEndPage() => _getEndPage(reference).integer;

  static final _setEndPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PDFTextStripper__setEndPage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setEndPage(int endPageValue)
  ///
  /// This will set the last page to be extracted by this class.
  ///@param endPageValue New value of 1-based endPage property.
  void setEndPage(int endPageValue) =>
      _setEndPage(reference, endPageValue).check();

  static final _setLineSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setLineSeparator")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setLineSeparator(java.lang.String separator)
  ///
  /// Set the desired line separator for output text. The line.separator system property is used if the line separator
  /// preference is not set explicitly using this method.
  ///@param separator The desired line separator string.
  void setLineSeparator(jni.JniString separator) =>
      _setLineSeparator(reference, separator.reference).check();

  static final _getLineSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getLineSeparator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLineSeparator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the line separator.
  ///@return The desired line separator string.
  jni.JniString getLineSeparator() =>
      jni.JniString.fromRef(_getLineSeparator(reference).object);

  static final _getWordSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getWordSeparator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getWordSeparator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the word separator.
  ///@return The desired word separator string.
  jni.JniString getWordSeparator() =>
      jni.JniString.fromRef(_getWordSeparator(reference).object);

  static final _setWordSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setWordSeparator")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setWordSeparator(java.lang.String separator)
  ///
  /// Set the desired word separator for output text. The PDFBox text extraction algorithm will output a space
  /// character if there is enough space between two words. By default a space character is used. If you need and
  /// accurate count of characters that are found in a PDF document then you might want to set the word separator to
  /// the empty string.
  ///@param separator The desired page separator string.
  void setWordSeparator(jni.JniString separator) =>
      _setWordSeparator(reference, separator.reference).check();

  static final _getSuppressDuplicateOverlappingText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getSuppressDuplicateOverlappingText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getSuppressDuplicateOverlappingText()
  ///
  /// @return Returns the suppressDuplicateOverlappingText.
  bool getSuppressDuplicateOverlappingText() =>
      _getSuppressDuplicateOverlappingText(reference).boolean;

  static final _getCurrentPageNo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getCurrentPageNo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected int getCurrentPageNo()
  ///
  /// Get the current page number that is being processed.
  ///@return A 1 based number representing the current page.
  int getCurrentPageNo() => _getCurrentPageNo(reference).integer;

  static final _getOutput = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getOutput")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected java.io.Writer getOutput()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The output stream that is being written to.
  ///@return The stream that output is being written to.
  jni.JniObject getOutput() =>
      jni.JniObject.fromRef(_getOutput(reference).object);

  static final _getCharactersByArticle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getCharactersByArticle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected java.util.List<java.util.List<org.apache.pdfbox.text.TextPosition>> getCharactersByArticle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Character strings are grouped by articles. It is quite common that there will only be a single article. This
  /// returns a List that contains List objects, the inner lists will contain TextPosition objects.
  ///@return A double List of TextPositions for all text strings on the page.
  jni.JniObject getCharactersByArticle() =>
      jni.JniObject.fromRef(_getCharactersByArticle(reference).object);

  static final _setSuppressDuplicateOverlappingText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "PDFTextStripper__setSuppressDuplicateOverlappingText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSuppressDuplicateOverlappingText(boolean suppressDuplicateOverlappingTextValue)
  ///
  /// By default the text stripper will attempt to remove text that overlapps each other. Word paints the same
  /// character several times in order to make it look bold. By setting this to false all text will be extracted, which
  /// means that certain sections will be duplicated, but better performance will be noticed.
  ///@param suppressDuplicateOverlappingTextValue The suppressDuplicateOverlappingText to set.
  void setSuppressDuplicateOverlappingText(
          bool suppressDuplicateOverlappingTextValue) =>
      _setSuppressDuplicateOverlappingText(
              reference, suppressDuplicateOverlappingTextValue ? 1 : 0)
          .check();

  static final _getSeparateByBeads = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getSeparateByBeads")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getSeparateByBeads()
  ///
  /// This will tell if the text stripper should separate by beads.
  ///@return If the text will be grouped by beads.
  bool getSeparateByBeads() => _getSeparateByBeads(reference).boolean;

  static final _setShouldSeparateByBeads = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("PDFTextStripper__setShouldSeparateByBeads")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setShouldSeparateByBeads(boolean aShouldSeparateByBeads)
  ///
  /// Set if the text stripper should group the text output by a list of beads. The default value is true!
  ///@param aShouldSeparateByBeads The new grouping of beads.
  void setShouldSeparateByBeads(bool aShouldSeparateByBeads) =>
      _setShouldSeparateByBeads(reference, aShouldSeparateByBeads ? 1 : 0)
          .check();

  static final _getEndBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getEndBookmark")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem getEndBookmark()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the bookmark where text extraction should end, inclusive. Default is null.
  ///@return The ending bookmark.
  jni.JniObject getEndBookmark() =>
      jni.JniObject.fromRef(_getEndBookmark(reference).object);

  static final _setEndBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setEndBookmark")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEndBookmark(org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem aEndBookmark)
  ///
  /// Set the bookmark where the text extraction should stop.
  ///@param aEndBookmark The ending bookmark.
  void setEndBookmark(jni.JniObject aEndBookmark) =>
      _setEndBookmark(reference, aEndBookmark.reference).check();

  static final _getStartBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getStartBookmark")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem getStartBookmark()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the bookmark where text extraction should start, inclusive. Default is null.
  ///@return The starting bookmark.
  jni.JniObject getStartBookmark() =>
      jni.JniObject.fromRef(_getStartBookmark(reference).object);

  static final _setStartBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setStartBookmark")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setStartBookmark(org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem aStartBookmark)
  ///
  /// Set the bookmark where text extraction should start, inclusive.
  ///@param aStartBookmark The starting bookmark.
  void setStartBookmark(jni.JniObject aStartBookmark) =>
      _setStartBookmark(reference, aStartBookmark.reference).check();

  static final _getAddMoreFormatting = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getAddMoreFormatting")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAddMoreFormatting()
  ///
  /// This will tell if the text stripper should add some more text formatting.
  ///@return true if some more text formatting will be added
  bool getAddMoreFormatting() => _getAddMoreFormatting(reference).boolean;

  static final _setAddMoreFormatting = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("PDFTextStripper__setAddMoreFormatting")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAddMoreFormatting(boolean newAddMoreFormatting)
  ///
  /// There will some additional text formatting be added if addMoreFormatting is set to true. Default is false.
  ///@param newAddMoreFormatting Tell PDFBox to add some more text formatting
  void setAddMoreFormatting(bool newAddMoreFormatting) =>
      _setAddMoreFormatting(reference, newAddMoreFormatting ? 1 : 0).check();

  static final _getSortByPosition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getSortByPosition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getSortByPosition()
  ///
  /// This will tell if the text stripper should sort the text tokens before writing to the stream.
  ///@return true If the text tokens will be sorted before being written.
  bool getSortByPosition() => _getSortByPosition(reference).boolean;

  static final _setSortByPosition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("PDFTextStripper__setSortByPosition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSortByPosition(boolean newSortByPosition)
  ///
  /// The order of the text tokens in a PDF file may not be in the same as they appear visually on the screen. For
  /// example, a PDF writer may write out all text by font, so all bold or larger text, then make a second pass and
  /// write out the normal text.<br>
  /// The default is to __not__ sort by position.<br>
  /// <br>
  /// A PDF writer could choose to write each character in a different order. By default PDFBox does __not__ sort
  /// the text tokens before processing them due to performance reasons.
  ///@param newSortByPosition Tell PDFBox to sort the text positions.
  void setSortByPosition(bool newSortByPosition) =>
      _setSortByPosition(reference, newSortByPosition ? 1 : 0).check();

  static final _getSpacingTolerance = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getSpacingTolerance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getSpacingTolerance()
  ///
  /// Get the current space width-based tolerance value that is being used to estimate where spaces in text should be
  /// added. Note that the default value for this has been determined from trial and error.
  ///@return The current tolerance / scaling factor
  double getSpacingTolerance() => _getSpacingTolerance(reference).float;

  static final _setSpacingTolerance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("PDFTextStripper__setSpacingTolerance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setSpacingTolerance(float spacingToleranceValue)
  ///
  /// Set the space width-based tolerance value that is used to estimate where spaces in text should be added. Note
  /// that the default value for this has been determined from trial and error. Setting this value larger will reduce
  /// the number of spaces added.
  ///@param spacingToleranceValue tolerance / scaling factor to use
  void setSpacingTolerance(double spacingToleranceValue) =>
      _setSpacingTolerance(reference, spacingToleranceValue).check();

  static final _getAverageCharTolerance = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getAverageCharTolerance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getAverageCharTolerance()
  ///
  /// Get the current character width-based tolerance value that is being used to estimate where spaces in text should
  /// be added. Note that the default value for this has been determined from trial and error.
  ///@return The current tolerance / scaling factor
  double getAverageCharTolerance() => _getAverageCharTolerance(reference).float;

  static final _setAverageCharTolerance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("PDFTextStripper__setAverageCharTolerance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setAverageCharTolerance(float averageCharToleranceValue)
  ///
  /// Set the character width-based tolerance value that is used to estimate where spaces in text should be added. Note
  /// that the default value for this has been determined from trial and error. Setting this value larger will reduce
  /// the number of spaces added.
  ///@param averageCharToleranceValue average tolerance / scaling factor to use
  void setAverageCharTolerance(double averageCharToleranceValue) =>
      _setAverageCharTolerance(reference, averageCharToleranceValue).check();

  static final _getIndentThreshold = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getIndentThreshold")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getIndentThreshold()
  ///
  /// returns the multiple of whitespace character widths for the current text which the current line start can be
  /// indented from the previous line start beyond which the current line start is considered to be a paragraph start.
  ///@return the number of whitespace character widths to use when detecting paragraph indents.
  double getIndentThreshold() => _getIndentThreshold(reference).float;

  static final _setIndentThreshold = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("PDFTextStripper__setIndentThreshold")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setIndentThreshold(float indentThresholdValue)
  ///
  /// sets the multiple of whitespace character widths for the current text which the current line start can be
  /// indented from the previous line start beyond which the current line start is considered to be a paragraph start.
  /// The default value is 2.0.
  ///@param indentThresholdValue the number of whitespace character widths to use when detecting paragraph indents.
  void setIndentThreshold(double indentThresholdValue) =>
      _setIndentThreshold(reference, indentThresholdValue).check();

  static final _getDropThreshold = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getDropThreshold")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getDropThreshold()
  ///
  /// the minimum whitespace, as a multiple of the max height of the current characters beyond which the current line
  /// start is considered to be a paragraph start.
  ///@return the character height multiple for max allowed whitespace between lines in the same paragraph.
  double getDropThreshold() => _getDropThreshold(reference).float;

  static final _setDropThreshold = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("PDFTextStripper__setDropThreshold")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setDropThreshold(float dropThresholdValue)
  ///
  /// sets the minimum whitespace, as a multiple of the max height of the current characters beyond which the current
  /// line start is considered to be a paragraph start. The default value is 2.5.
  ///@param dropThresholdValue the character height multiple for max allowed whitespace between lines in the same
  /// paragraph.
  void setDropThreshold(double dropThresholdValue) =>
      _setDropThreshold(reference, dropThresholdValue).check();

  static final _getParagraphStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getParagraphStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getParagraphStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the beginning of a paragraph.
  ///@return the paragraph start string
  jni.JniString getParagraphStart() =>
      jni.JniString.fromRef(_getParagraphStart(reference).object);

  static final _setParagraphStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setParagraphStart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setParagraphStart(java.lang.String s)
  ///
  /// Sets the string which will be used at the beginning of a paragraph.
  ///@param s the paragraph start string
  void setParagraphStart(jni.JniString s) =>
      _setParagraphStart(reference, s.reference).check();

  static final _getParagraphEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getParagraphEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getParagraphEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the end of a paragraph.
  ///@return the paragraph end string
  jni.JniString getParagraphEnd() =>
      jni.JniString.fromRef(_getParagraphEnd(reference).object);

  static final _setParagraphEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setParagraphEnd")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setParagraphEnd(java.lang.String s)
  ///
  /// Sets the string which will be used at the end of a paragraph.
  ///@param s the paragraph end string
  void setParagraphEnd(jni.JniString s) =>
      _setParagraphEnd(reference, s.reference).check();

  static final _getPageStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getPageStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPageStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the beginning of a page.
  ///@return the page start string
  jni.JniString getPageStart() =>
      jni.JniString.fromRef(_getPageStart(reference).object);

  static final _setPageStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setPageStart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setPageStart(java.lang.String pageStartValue)
  ///
  /// Sets the string which will be used at the beginning of a page.
  ///@param pageStartValue the page start string
  void setPageStart(jni.JniString pageStartValue) =>
      _setPageStart(reference, pageStartValue.reference).check();

  static final _getPageEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getPageEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPageEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the end of a page.
  ///@return the page end string
  jni.JniString getPageEnd() =>
      jni.JniString.fromRef(_getPageEnd(reference).object);

  static final _setPageEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setPageEnd")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setPageEnd(java.lang.String pageEndValue)
  ///
  /// Sets the string which will be used at the end of a page.
  ///@param pageEndValue the page end string
  void setPageEnd(jni.JniString pageEndValue) =>
      _setPageEnd(reference, pageEndValue.reference).check();

  static final _getArticleStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getArticleStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getArticleStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the beginning of an article.
  ///@return the article start string
  jni.JniString getArticleStart() =>
      jni.JniString.fromRef(_getArticleStart(reference).object);

  static final _setArticleStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setArticleStart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setArticleStart(java.lang.String articleStartValue)
  ///
  /// Sets the string which will be used at the beginning of an article.
  ///@param articleStartValue the article start string
  void setArticleStart(jni.JniString articleStartValue) =>
      _setArticleStart(reference, articleStartValue.reference).check();

  static final _getArticleEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getArticleEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getArticleEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the end of an article.
  ///@return the article end string
  jni.JniString getArticleEnd() =>
      jni.JniString.fromRef(_getArticleEnd(reference).object);

  static final _setArticleEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setArticleEnd")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setArticleEnd(java.lang.String articleEndValue)
  ///
  /// Sets the string which will be used at the end of an article.
  ///@param articleEndValue the article end string
  void setArticleEnd(jni.JniString articleEndValue) =>
      _setArticleEnd(reference, articleEndValue.reference).check();

  static final _handleLineSeparation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("PDFTextStripper__handleLineSeparation")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: private org.apache.pdfbox.text.PDFTextStripper.PositionWrapper handleLineSeparation(org.apache.pdfbox.text.PDFTextStripper.PositionWrapper current, org.apache.pdfbox.text.PDFTextStripper.PositionWrapper lastPosition, org.apache.pdfbox.text.PDFTextStripper.PositionWrapper lastLineStartPosition, float maxHeightForLine)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// handles the line separator for a new line given the specified current and previous TextPositions.
  ///@param current the current text position
  ///@param lastPosition the previous text position
  ///@param lastLineStartPosition the last text position that followed a line separator.
  ///@param maxHeightForLine max height for positions since lastLineStartPosition
  ///@return start position of the last line
  ///@throws IOException if something went wrong
  jni.JniObject handleLineSeparation(
          jni.JniObject current,
          jni.JniObject lastPosition,
          jni.JniObject lastLineStartPosition,
          double maxHeightForLine) =>
      jni.JniObject.fromRef(_handleLineSeparation(
              reference,
              current.reference,
              lastPosition.reference,
              lastLineStartPosition.reference,
              maxHeightForLine)
          .object);

  static final _isParagraphSeparation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("PDFTextStripper__isParagraphSeparation")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: private void isParagraphSeparation(org.apache.pdfbox.text.PDFTextStripper.PositionWrapper position, org.apache.pdfbox.text.PDFTextStripper.PositionWrapper lastPosition, org.apache.pdfbox.text.PDFTextStripper.PositionWrapper lastLineStartPosition, float maxHeightForLine)
  ///
  /// tests the relationship between the last text position, the current text position and the last text position that
  /// followed a line separator to decide if the gap represents a paragraph separation. This should <i>only</i> be
  /// called for consecutive text positions that first pass the line separation test.
  ///
  /// This base implementation tests to see if the lastLineStartPosition is null OR if the current vertical position
  /// has dropped below the last text vertical position by at least 2.5 times the current text height OR if the current
  /// horizontal position is indented by at least 2 times the current width of a space character.
  ///
  ///
  ///
  /// This also attempts to identify text that is indented under a hanging indent.
  ///
  ///
  ///
  /// This method sets the isParagraphStart and isHangingIndent flags on the current position object.
  ///
  ///
  ///@param position the current text position. This may have its isParagraphStart or isHangingIndent flags set upon
  /// return.
  ///@param lastPosition the previous text position (should not be null).
  ///@param lastLineStartPosition the last text position that followed a line separator, or null.
  ///@param maxHeightForLine max height for text positions since lasLineStartPosition.
  void isParagraphSeparation(jni.JniObject position, jni.JniObject lastPosition,
          jni.JniObject lastLineStartPosition, double maxHeightForLine) =>
      _isParagraphSeparation(
              reference,
              position.reference,
              lastPosition.reference,
              lastLineStartPosition.reference,
              maxHeightForLine)
          .check();

  static final _multiplyFloat = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Float,
                  ffi.Float)>>("PDFTextStripper__multiplyFloat")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, double, double)>();

  /// from: private float multiplyFloat(float value1, float value2)
  double multiplyFloat(double value1, double value2) =>
      _multiplyFloat(reference, value1, value2).float;

  static final _writeParagraphSeparator = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__writeParagraphSeparator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeParagraphSeparator()
  ///
  /// writes the paragraph separator string to the output.
  ///@throws IOException if something went wrong
  void writeParagraphSeparator() => _writeParagraphSeparator(reference).check();

  static final _writeParagraphStart = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__writeParagraphStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeParagraphStart()
  ///
  /// Write something (if defined) at the start of a paragraph.
  ///@throws IOException if something went wrong
  void writeParagraphStart() => _writeParagraphStart(reference).check();

  static final _writeParagraphEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writeParagraphEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeParagraphEnd()
  ///
  /// Write something (if defined) at the end of a paragraph.
  ///@throws IOException if something went wrong
  void writeParagraphEnd() => _writeParagraphEnd(reference).check();

  static final _writePageStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writePageStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writePageStart()
  ///
  /// Write something (if defined) at the start of a page.
  ///@throws IOException if something went wrong
  void writePageStart() => _writePageStart(reference).check();

  static final _writePageEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writePageEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writePageEnd()
  ///
  /// Write something (if defined) at the end of a page.
  ///@throws IOException if something went wrong
  void writePageEnd() => _writePageEnd(reference).check();

  static final _matchListItemPattern = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__matchListItemPattern")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.util.regex.Pattern matchListItemPattern(org.apache.pdfbox.text.PDFTextStripper.PositionWrapper pw)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// returns the list item Pattern object that matches the text at the specified PositionWrapper or null if the text
  /// does not match such a pattern. The list of Patterns tested against is given by the \#getListItemPatterns()
  /// method. To add to the list, simply override that method (if sub-classing) or explicitly supply your own list
  /// using \#setListItemPatterns(List).
  ///@param pw position
  ///@return the matching pattern
  jni.JniObject matchListItemPattern(jni.JniObject pw) => jni.JniObject.fromRef(
      _matchListItemPattern(reference, pw.reference).object);

  static final _setListItemPatterns = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__setListItemPatterns")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void setListItemPatterns(java.util.List<java.util.regex.Pattern> patterns)
  ///
  /// use to supply a different set of regular expression patterns for matching list item starts.
  ///@param patterns list of patterns
  void setListItemPatterns(jni.JniObject patterns) =>
      _setListItemPatterns(reference, patterns.reference).check();

  static final _getListItemPatterns = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getListItemPatterns")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected java.util.List<java.util.regex.Pattern> getListItemPatterns()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// returns a list of regular expression Patterns representing different common list item formats. For example
  /// numbered items of form:
  /// <ol>
  /// <li>some text</li>
  /// <li>more text</li>
  /// </ol>
  /// or
  /// <ul>
  /// <li>some text</li>
  /// <li>more text</li>
  /// </ul>
  /// etc., all begin with some character pattern. The pattern "\\d+\." (matches "1.", "2.", ...) or "\[\\d+\]"
  /// (matches "[1]", "[2]", ...).
  ///
  /// This method returns a list of such regular expression Patterns.
  ///@return a list of Pattern objects.
  jni.JniObject getListItemPatterns() =>
      jni.JniObject.fromRef(_getListItemPatterns(reference).object);

  static final _matchPattern = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__matchPattern")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static protected java.util.regex.Pattern matchPattern(java.lang.String string, java.util.List<java.util.regex.Pattern> patterns)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// iterates over the specified list of Patterns until it finds one that matches the specified string. Then returns
  /// the Pattern.
  ///
  /// Order of the supplied list of patterns is important as most common patterns should come first. Patterns should be
  /// strict in general, and all will be used with case sensitivity on.
  ///
  ///
  ///@param string the string to be searched
  ///@param patterns list of patterns
  ///@return matching pattern
  static jni.JniObject matchPattern(
          jni.JniString string, jni.JniObject patterns) =>
      jni.JniObject.fromRef(
          _matchPattern(string.reference, patterns.reference).object);

  static final _writeLine = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writeLine")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private void writeLine(java.util.List<org.apache.pdfbox.text.PDFTextStripper.WordWithTextPositions> line)
  ///
  /// Write a list of string containing a whole line of a document.
  ///@param line a list with the words of the given line
  ///@throws IOException if something went wrong
  void writeLine(jni.JniObject line) =>
      _writeLine(reference, line.reference).check();

  static final _normalize = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__normalize")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.util.List<org.apache.pdfbox.text.PDFTextStripper.WordWithTextPositions> normalize(java.util.List<org.apache.pdfbox.text.PDFTextStripper.LineItem> line)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Normalize the given list of TextPositions.
  ///@param line list of TextPositions
  ///@return a list of strings, one string for every word
  jni.JniObject normalize(jni.JniObject line) =>
      jni.JniObject.fromRef(_normalize(reference, line.reference).object);

  static final _handleDirection = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__handleDirection")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String handleDirection(java.lang.String word)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Handles the LTR and RTL direction of the given words. The whole implementation stands and falls with the given
  /// word. If the word is a full line, the results will be the best. If the word contains of single words or
  /// characters, the order of the characters in a word or words in a line may wrong, due to RTL and LTR marks and
  /// characters!
  ///
  /// Based on http://www.nesterovsky-bros.com/weblog/2013/07/28/VisualToLogicalConversionInJava.aspx
  ///@param word The word that shall be processed
  ///@return new word with the correct direction of the containing characters
  jni.JniString handleDirection(jni.JniString word) =>
      jni.JniString.fromRef(_handleDirection(reference, word.reference).object);

  static final _parseBidiFile = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__parseBidiFile")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: private static void parseBidiFile(java.io.InputStream inputStream)
  ///
  /// This method parses the bidi file provided as inputstream.
  ///@param inputStream - The bidi file as inputstream
  ///@throws IOException if any line could not be read by the LineNumberReader
  static void parseBidiFile(jni.JniObject inputStream) =>
      _parseBidiFile(inputStream.reference).check();

  static final _createWord = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__createWord")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: private org.apache.pdfbox.text.PDFTextStripper.WordWithTextPositions createWord(java.lang.String word, java.util.List<org.apache.pdfbox.text.TextPosition> wordPositions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used within \#normalize(List) to create a single WordWithTextPositions entry.
  jni.JniObject createWord(jni.JniString word, jni.JniObject wordPositions) =>
      jni.JniObject.fromRef(
          _createWord(reference, word.reference, wordPositions.reference)
              .object);

  static final _normalizeWord = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__normalizeWord")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.String normalizeWord(java.lang.String word)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Normalize certain Unicode characters. For example, convert the single "fi" ligature to "f" and "i". Also
  /// normalises Arabic and Hebrew presentation forms.
  ///@param word Word to normalize
  ///@return Normalized word
  jni.JniString normalizeWord(jni.JniString word) =>
      jni.JniString.fromRef(_normalizeWord(reference, word.reference).object);

  static final _normalizeAdd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__normalizeAdd")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: private java.lang.StringBuilder normalizeAdd(java.util.List<org.apache.pdfbox.text.PDFTextStripper.WordWithTextPositions> normalized, java.lang.StringBuilder lineBuilder, java.util.List<org.apache.pdfbox.text.TextPosition> wordPositions, org.apache.pdfbox.text.PDFTextStripper.LineItem item)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used within \#normalize(List) to handle a TextPosition.
  ///@return The StringBuilder that must be used when calling this method.
  jni.JniObject normalizeAdd(
          jni.JniObject normalized,
          jni.JniObject lineBuilder,
          jni.JniObject wordPositions,
          jni.JniObject item) =>
      jni.JniObject.fromRef(_normalizeAdd(reference, normalized.reference,
              lineBuilder.reference, wordPositions.reference, item.reference)
          .object);
}
