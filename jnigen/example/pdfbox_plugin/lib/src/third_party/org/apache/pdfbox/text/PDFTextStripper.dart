// Generated from Apache PDFBox library which is licensed under the Apache License 2.0.
// The following copyright from the original authors applies.
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../pdmodel/PDDocument.dart" as pddocument_;
import "../../../../_init.dart";

/// from: org.apache.pdfbox.text.PDFTextStripper
///
/// This class will take a pdf document and strip out all of the text and ignore the formatting and such. Please note; it
/// is up to clients of this class to verify that a specific user has the correct permissions to extract text from the
/// PDF document.
///
/// The basic flow of this process is that we get a document and use a series of processXXX() functions that work on
/// smaller and smaller chunks of the page. Eventually, we fully process each page and then print it.
///@author Ben Litchfield
class PDFTextStripper extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  PDFTextStripper.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $PDFTextStripperType();
  static final _get_LINE_SEPARATOR = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_PDFTextStripper__LINE_SEPARATOR")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  /// from: protected final java.lang.String LINE_SEPARATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The platform's line separator.
  jni.JString get LINE_SEPARATOR =>
      const jni.JStringType().fromRef(_get_LINE_SEPARATOR(reference).object);

  static final _get_charactersByArticle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_PDFTextStripper__charactersByArticle")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_charactersByArticle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_PDFTextStripper__charactersByArticle")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: protected java.util.ArrayList<java.util.List<org.apache.pdfbox.text.TextPosition>> charactersByArticle
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The charactersByArticle is used to extract text by article divisions. For example a PDF that has two columns like
  /// a newspaper, we want to extract the first column and then the second column. In this example the PDF would have 2
  /// beads(or articles), one for each column. The size of the charactersByArticle would be 5, because not all text on
  /// the screen will fall into one of the articles. The five divisions are shown below
  ///
  /// Text before first article
  /// first article text
  /// text between first article and second article
  /// second article text
  /// text after second article
  ///
  /// Most PDFs won't have any beads, so charactersByArticle will contain a single entry.
  jni.JObject get charactersByArticle => const jni.JObjectType()
      .fromRef(_get_charactersByArticle(reference).object);

  /// from: protected java.util.ArrayList<java.util.List<org.apache.pdfbox.text.TextPosition>> charactersByArticle
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The charactersByArticle is used to extract text by article divisions. For example a PDF that has two columns like
  /// a newspaper, we want to extract the first column and then the second column. In this example the PDF would have 2
  /// beads(or articles), one for each column. The size of the charactersByArticle would be 5, because not all text on
  /// the screen will fall into one of the articles. The five divisions are shown below
  ///
  /// Text before first article
  /// first article text
  /// text between first article and second article
  /// second article text
  /// text after second article
  ///
  /// Most PDFs won't have any beads, so charactersByArticle will contain a single entry.
  set charactersByArticle(jni.JObject value) =>
      _set_charactersByArticle(reference, value.reference).check();

  static final _get_document = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_PDFTextStripper__document")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_document = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__document")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: protected org.apache.pdfbox.pdmodel.PDDocument document
  /// The returned object must be deleted after use, by calling the `delete` method.
  pddocument_.PDDocument get document => const pddocument_.$PDDocumentType()
      .fromRef(_get_document(reference).object);

  /// from: protected org.apache.pdfbox.pdmodel.PDDocument document
  /// The returned object must be deleted after use, by calling the `delete` method.
  set document(pddocument_.PDDocument value) =>
      _set_document(reference, value.reference).check();

  static final _get_output = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_PDFTextStripper__output")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_output = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_PDFTextStripper__output")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: protected java.io.Writer output
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject get output =>
      const jni.JObjectType().fromRef(_get_output(reference).object);

  /// from: protected java.io.Writer output
  /// The returned object must be deleted after use, by calling the `delete` method.
  set output(jni.JObject value) =>
      _set_output(reference, value.reference).check();

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "PDFTextStripper__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Instantiate a new PDFTextStripper object.
  ///@throws IOException If there is an error loading the properties.
  factory PDFTextStripper() {
    return PDFTextStripper.fromRef(_ctor().object);
  }

  static final _getText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getText(org.apache.pdfbox.pdmodel.PDDocument doc)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will return the text of a document. See writeText. <br>
  /// NOTE: The document must not be encrypted when coming into this method.
  ///
  /// IMPORTANT: By default, text extraction is done in the same sequence as the text in the PDF page content stream.
  /// PDF is a graphic format, not a text format, and unlike HTML, it has no requirements that text one on page
  /// be rendered in a certain order. The order is the one that was determined by the software that created the
  /// PDF. To get text sorted from left to right and top to botton, use \#setSortByPosition(boolean).
  ///@param doc The document to get the text from.
  ///@return The text of the PDF document.
  ///@throws IOException if the doc state is invalid or it is encrypted.
  jni.JString getText(
    pddocument_.PDDocument doc,
  ) {
    return const jni.JStringType()
        .fromRef(_getText(reference, doc.reference).object);
  }

  static final _writeText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writeText")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void writeText(org.apache.pdfbox.pdmodel.PDDocument doc, java.io.Writer outputStream)
  ///
  /// This will take a PDDocument and write the text of that document to the print writer.
  ///@param doc The document to get the data from.
  ///@param outputStream The location to put the text.
  ///@throws IOException If the doc is in an invalid state.
  void writeText(
    pddocument_.PDDocument doc,
    jni.JObject outputStream,
  ) {
    return _writeText(reference, doc.reference, outputStream.reference).check();
  }

  static final _processPages = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__processPages")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void processPages(org.apache.pdfbox.pdmodel.PDPageTree pages)
  ///
  /// This will process all of the pages and the text that is in them.
  ///@param pages The pages object in the document.
  ///@throws IOException If there is an error parsing the text.
  void processPages(
    jni.JObject pages,
  ) {
    return _processPages(reference, pages.reference).check();
  }

  static final _startDocument = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__startDocument")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void startDocument(org.apache.pdfbox.pdmodel.PDDocument document)
  ///
  /// This method is available for subclasses of this class. It will be called before processing of the document start.
  ///@param document The PDF document that is being processed.
  ///@throws IOException If an IO error occurs.
  void startDocument(
    pddocument_.PDDocument document,
  ) {
    return _startDocument(reference, document.reference).check();
  }

  static final _endDocument = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__endDocument")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void endDocument(org.apache.pdfbox.pdmodel.PDDocument document)
  ///
  /// This method is available for subclasses of this class. It will be called after processing of the document
  /// finishes.
  ///@param document The PDF document that is being processed.
  ///@throws IOException If an IO error occurs.
  void endDocument(
    pddocument_.PDDocument document,
  ) {
    return _endDocument(reference, document.reference).check();
  }

  static final _processPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__processPage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void processPage(org.apache.pdfbox.pdmodel.PDPage page)
  ///
  /// This will process the contents of a page.
  ///@param page The page to process.
  ///@throws IOException If there is an error processing the page.
  void processPage(
    jni.JObject page,
  ) {
    return _processPage(reference, page.reference).check();
  }

  static final _startArticle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__startArticle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void startArticle()
  ///
  /// Start a new article, which is typically defined as a column on a single page (also referred to as a bead). This
  /// assumes that the primary direction of text is left to right. Default implementation is to do nothing. Subclasses
  /// may provide additional information.
  ///@throws IOException If there is any error writing to the stream.
  void startArticle() {
    return _startArticle(reference).check();
  }

  static final _startArticle1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("PDFTextStripper__startArticle1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected void startArticle(boolean isLTR)
  ///
  /// Start a new article, which is typically defined as a column on a single page (also referred to as a bead).
  /// Default implementation is to do nothing. Subclasses may provide additional information.
  ///@param isLTR true if primary direction of text is left to right.
  ///@throws IOException If there is any error writing to the stream.
  void startArticle1(
    bool isLTR,
  ) {
    return _startArticle1(reference, isLTR ? 1 : 0).check();
  }

  static final _endArticle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__endArticle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void endArticle()
  ///
  /// End an article. Default implementation is to do nothing. Subclasses may provide additional information.
  ///@throws IOException If there is any error writing to the stream.
  void endArticle() {
    return _endArticle(reference).check();
  }

  static final _startPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__startPage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void startPage(org.apache.pdfbox.pdmodel.PDPage page)
  ///
  /// Start a new page. Default implementation is to do nothing. Subclasses may provide additional information.
  ///@param page The page we are about to process.
  ///@throws IOException If there is any error writing to the stream.
  void startPage(
    jni.JObject page,
  ) {
    return _startPage(reference, page.reference).check();
  }

  static final _endPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__endPage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void endPage(org.apache.pdfbox.pdmodel.PDPage page)
  ///
  /// End a page. Default implementation is to do nothing. Subclasses may provide additional information.
  ///@param page The page we are about to process.
  ///@throws IOException If there is any error writing to the stream.
  void endPage(
    jni.JObject page,
  ) {
    return _endPage(reference, page.reference).check();
  }

  static final _writePage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writePage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writePage()
  ///
  /// This will print the text of the processed page to "output". It will estimate, based on the coordinates of the
  /// text, where newlines and word spacings should be placed. The text will be sorted only if that feature was
  /// enabled.
  ///@throws IOException If there is an error writing the text.
  void writePage() {
    return _writePage(reference).check();
  }

  static final _writeLineSeparator = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__writeLineSeparator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeLineSeparator()
  ///
  /// Write the line separator value to the output stream.
  ///@throws IOException If there is a problem writing out the line separator to the document.
  void writeLineSeparator() {
    return _writeLineSeparator(reference).check();
  }

  static final _writeWordSeparator = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__writeWordSeparator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeWordSeparator()
  ///
  /// Write the word separator value to the output stream.
  ///@throws IOException If there is a problem writing out the word separator to the document.
  void writeWordSeparator() {
    return _writeWordSeparator(reference).check();
  }

  static final _writeCharacters = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writeCharacters")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeCharacters(org.apache.pdfbox.text.TextPosition text)
  ///
  /// Write the string in TextPosition to the output stream.
  ///@param text The text to write to the stream.
  ///@throws IOException If there is an error when writing the text.
  void writeCharacters(
    jni.JObject text,
  ) {
    return _writeCharacters(reference, text.reference).check();
  }

  static final _writeString = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writeString")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeString(java.lang.String text, java.util.List<org.apache.pdfbox.text.TextPosition> textPositions)
  ///
  /// Write a Java string to the output stream. The default implementation will ignore the <code>textPositions</code>
  /// and just calls \#writeString(String).
  ///@param text The text to write to the stream.
  ///@param textPositions The TextPositions belonging to the text.
  ///@throws IOException If there is an error when writing the text.
  void writeString(
    jni.JString text,
    jni.JObject textPositions,
  ) {
    return _writeString(reference, text.reference, textPositions.reference)
        .check();
  }

  static final _writeString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writeString1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeString(java.lang.String text)
  ///
  /// Write a Java string to the output stream.
  ///@param text The text to write to the stream.
  ///@throws IOException If there is an error when writing the text.
  void writeString1(
    jni.JString text,
  ) {
    return _writeString1(reference, text.reference).check();
  }

  static final _processTextPosition = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__processTextPosition")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void processTextPosition(org.apache.pdfbox.text.TextPosition text)
  ///
  /// This will process a TextPosition object and add the text to the list of characters on a page. It takes care of
  /// overlapping text.
  ///@param text The text to process.
  void processTextPosition(
    jni.JObject text,
  ) {
    return _processTextPosition(reference, text.reference).check();
  }

  static final _getStartPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getStartPage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getStartPage()
  ///
  /// This is the page that the text extraction will start on. The pages start at page 1. For example in a 5 page PDF
  /// document, if the start page is 1 then all pages will be extracted. If the start page is 4 then pages 4 and 5 will
  /// be extracted. The default value is 1.
  ///@return Value of property startPage.
  int getStartPage() {
    return _getStartPage(reference).integer;
  }

  static final _setStartPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PDFTextStripper__setStartPage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setStartPage(int startPageValue)
  ///
  /// This will set the first page to be extracted by this class.
  ///@param startPageValue New value of 1-based startPage property.
  void setStartPage(
    int startPageValue,
  ) {
    return _setStartPage(reference, startPageValue).check();
  }

  static final _getEndPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getEndPage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getEndPage()
  ///
  /// This will get the last page that will be extracted. This is inclusive, for example if a 5 page PDF an endPage
  /// value of 5 would extract the entire document, an end page of 2 would extract pages 1 and 2. This defaults to
  /// Integer.MAX_VALUE such that all pages of the pdf will be extracted.
  ///@return Value of property endPage.
  int getEndPage() {
    return _getEndPage(reference).integer;
  }

  static final _setEndPage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PDFTextStripper__setEndPage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setEndPage(int endPageValue)
  ///
  /// This will set the last page to be extracted by this class.
  ///@param endPageValue New value of 1-based endPage property.
  void setEndPage(
    int endPageValue,
  ) {
    return _setEndPage(reference, endPageValue).check();
  }

  static final _setLineSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setLineSeparator")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setLineSeparator(java.lang.String separator)
  ///
  /// Set the desired line separator for output text. The line.separator system property is used if the line separator
  /// preference is not set explicitly using this method.
  ///@param separator The desired line separator string.
  void setLineSeparator(
    jni.JString separator,
  ) {
    return _setLineSeparator(reference, separator.reference).check();
  }

  static final _getLineSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getLineSeparator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLineSeparator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the line separator.
  ///@return The desired line separator string.
  jni.JString getLineSeparator() {
    return const jni.JStringType().fromRef(_getLineSeparator(reference).object);
  }

  static final _getWordSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getWordSeparator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getWordSeparator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This will get the word separator.
  ///@return The desired word separator string.
  jni.JString getWordSeparator() {
    return const jni.JStringType().fromRef(_getWordSeparator(reference).object);
  }

  static final _setWordSeparator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setWordSeparator")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setWordSeparator(java.lang.String separator)
  ///
  /// Set the desired word separator for output text. The PDFBox text extraction algorithm will output a space
  /// character if there is enough space between two words. By default a space character is used. If you need and
  /// accurate count of characters that are found in a PDF document then you might want to set the word separator to
  /// the empty string.
  ///@param separator The desired page separator string.
  void setWordSeparator(
    jni.JString separator,
  ) {
    return _setWordSeparator(reference, separator.reference).check();
  }

  static final _getSuppressDuplicateOverlappingText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getSuppressDuplicateOverlappingText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getSuppressDuplicateOverlappingText()
  ///
  /// @return Returns the suppressDuplicateOverlappingText.
  bool getSuppressDuplicateOverlappingText() {
    return _getSuppressDuplicateOverlappingText(reference).boolean;
  }

  static final _getCurrentPageNo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getCurrentPageNo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected int getCurrentPageNo()
  ///
  /// Get the current page number that is being processed.
  ///@return A 1 based number representing the current page.
  int getCurrentPageNo() {
    return _getCurrentPageNo(reference).integer;
  }

  static final _getOutput = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getOutput")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected java.io.Writer getOutput()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The output stream that is being written to.
  ///@return The stream that output is being written to.
  jni.JObject getOutput() {
    return const jni.JObjectType().fromRef(_getOutput(reference).object);
  }

  static final _getCharactersByArticle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getCharactersByArticle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected java.util.List<java.util.List<org.apache.pdfbox.text.TextPosition>> getCharactersByArticle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Character strings are grouped by articles. It is quite common that there will only be a single article. This
  /// returns a List that contains List objects, the inner lists will contain TextPosition objects.
  ///@return A double List of TextPositions for all text strings on the page.
  jni.JObject getCharactersByArticle() {
    return const jni.JObjectType()
        .fromRef(_getCharactersByArticle(reference).object);
  }

  static final _setSuppressDuplicateOverlappingText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "PDFTextStripper__setSuppressDuplicateOverlappingText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSuppressDuplicateOverlappingText(boolean suppressDuplicateOverlappingTextValue)
  ///
  /// By default the text stripper will attempt to remove text that overlapps each other. Word paints the same
  /// character several times in order to make it look bold. By setting this to false all text will be extracted, which
  /// means that certain sections will be duplicated, but better performance will be noticed.
  ///@param suppressDuplicateOverlappingTextValue The suppressDuplicateOverlappingText to set.
  void setSuppressDuplicateOverlappingText(
    bool suppressDuplicateOverlappingTextValue,
  ) {
    return _setSuppressDuplicateOverlappingText(
            reference, suppressDuplicateOverlappingTextValue ? 1 : 0)
        .check();
  }

  static final _getSeparateByBeads = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getSeparateByBeads")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getSeparateByBeads()
  ///
  /// This will tell if the text stripper should separate by beads.
  ///@return If the text will be grouped by beads.
  bool getSeparateByBeads() {
    return _getSeparateByBeads(reference).boolean;
  }

  static final _setShouldSeparateByBeads = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("PDFTextStripper__setShouldSeparateByBeads")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setShouldSeparateByBeads(boolean aShouldSeparateByBeads)
  ///
  /// Set if the text stripper should group the text output by a list of beads. The default value is true!
  ///@param aShouldSeparateByBeads The new grouping of beads.
  void setShouldSeparateByBeads(
    bool aShouldSeparateByBeads,
  ) {
    return _setShouldSeparateByBeads(reference, aShouldSeparateByBeads ? 1 : 0)
        .check();
  }

  static final _getEndBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getEndBookmark")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem getEndBookmark()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the bookmark where text extraction should end, inclusive. Default is null.
  ///@return The ending bookmark.
  jni.JObject getEndBookmark() {
    return const jni.JObjectType().fromRef(_getEndBookmark(reference).object);
  }

  static final _setEndBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setEndBookmark")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEndBookmark(org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem aEndBookmark)
  ///
  /// Set the bookmark where the text extraction should stop.
  ///@param aEndBookmark The ending bookmark.
  void setEndBookmark(
    jni.JObject aEndBookmark,
  ) {
    return _setEndBookmark(reference, aEndBookmark.reference).check();
  }

  static final _getStartBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getStartBookmark")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem getStartBookmark()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the bookmark where text extraction should start, inclusive. Default is null.
  ///@return The starting bookmark.
  jni.JObject getStartBookmark() {
    return const jni.JObjectType().fromRef(_getStartBookmark(reference).object);
  }

  static final _setStartBookmark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setStartBookmark")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setStartBookmark(org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem aStartBookmark)
  ///
  /// Set the bookmark where text extraction should start, inclusive.
  ///@param aStartBookmark The starting bookmark.
  void setStartBookmark(
    jni.JObject aStartBookmark,
  ) {
    return _setStartBookmark(reference, aStartBookmark.reference).check();
  }

  static final _getAddMoreFormatting = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getAddMoreFormatting")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAddMoreFormatting()
  ///
  /// This will tell if the text stripper should add some more text formatting.
  ///@return true if some more text formatting will be added
  bool getAddMoreFormatting() {
    return _getAddMoreFormatting(reference).boolean;
  }

  static final _setAddMoreFormatting = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("PDFTextStripper__setAddMoreFormatting")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAddMoreFormatting(boolean newAddMoreFormatting)
  ///
  /// There will some additional text formatting be added if addMoreFormatting is set to true. Default is false.
  ///@param newAddMoreFormatting Tell PDFBox to add some more text formatting
  void setAddMoreFormatting(
    bool newAddMoreFormatting,
  ) {
    return _setAddMoreFormatting(reference, newAddMoreFormatting ? 1 : 0)
        .check();
  }

  static final _getSortByPosition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getSortByPosition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getSortByPosition()
  ///
  /// This will tell if the text stripper should sort the text tokens before writing to the stream.
  ///@return true If the text tokens will be sorted before being written.
  bool getSortByPosition() {
    return _getSortByPosition(reference).boolean;
  }

  static final _setSortByPosition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("PDFTextStripper__setSortByPosition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSortByPosition(boolean newSortByPosition)
  ///
  /// The order of the text tokens in a PDF file may not be in the same as they appear visually on the screen. For
  /// example, a PDF writer may write out all text by font, so all bold or larger text, then make a second pass and
  /// write out the normal text.<br>
  /// The default is to __not__ sort by position.<br>
  /// <br>
  /// A PDF writer could choose to write each character in a different order. By default PDFBox does __not__ sort
  /// the text tokens before processing them due to performance reasons.
  ///@param newSortByPosition Tell PDFBox to sort the text positions.
  void setSortByPosition(
    bool newSortByPosition,
  ) {
    return _setSortByPosition(reference, newSortByPosition ? 1 : 0).check();
  }

  static final _getSpacingTolerance = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getSpacingTolerance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getSpacingTolerance()
  ///
  /// Get the current space width-based tolerance value that is being used to estimate where spaces in text should be
  /// added. Note that the default value for this has been determined from trial and error.
  ///@return The current tolerance / scaling factor
  double getSpacingTolerance() {
    return _getSpacingTolerance(reference).float;
  }

  static final _setSpacingTolerance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("PDFTextStripper__setSpacingTolerance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setSpacingTolerance(float spacingToleranceValue)
  ///
  /// Set the space width-based tolerance value that is used to estimate where spaces in text should be added. Note
  /// that the default value for this has been determined from trial and error. Setting this value larger will reduce
  /// the number of spaces added.
  ///@param spacingToleranceValue tolerance / scaling factor to use
  void setSpacingTolerance(
    double spacingToleranceValue,
  ) {
    return _setSpacingTolerance(reference, spacingToleranceValue).check();
  }

  static final _getAverageCharTolerance = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getAverageCharTolerance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getAverageCharTolerance()
  ///
  /// Get the current character width-based tolerance value that is being used to estimate where spaces in text should
  /// be added. Note that the default value for this has been determined from trial and error.
  ///@return The current tolerance / scaling factor
  double getAverageCharTolerance() {
    return _getAverageCharTolerance(reference).float;
  }

  static final _setAverageCharTolerance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("PDFTextStripper__setAverageCharTolerance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setAverageCharTolerance(float averageCharToleranceValue)
  ///
  /// Set the character width-based tolerance value that is used to estimate where spaces in text should be added. Note
  /// that the default value for this has been determined from trial and error. Setting this value larger will reduce
  /// the number of spaces added.
  ///@param averageCharToleranceValue average tolerance / scaling factor to use
  void setAverageCharTolerance(
    double averageCharToleranceValue,
  ) {
    return _setAverageCharTolerance(reference, averageCharToleranceValue)
        .check();
  }

  static final _getIndentThreshold = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getIndentThreshold")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getIndentThreshold()
  ///
  /// returns the multiple of whitespace character widths for the current text which the current line start can be
  /// indented from the previous line start beyond which the current line start is considered to be a paragraph start.
  ///@return the number of whitespace character widths to use when detecting paragraph indents.
  double getIndentThreshold() {
    return _getIndentThreshold(reference).float;
  }

  static final _setIndentThreshold = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("PDFTextStripper__setIndentThreshold")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setIndentThreshold(float indentThresholdValue)
  ///
  /// sets the multiple of whitespace character widths for the current text which the current line start can be
  /// indented from the previous line start beyond which the current line start is considered to be a paragraph start.
  /// The default value is 2.0.
  ///@param indentThresholdValue the number of whitespace character widths to use when detecting paragraph indents.
  void setIndentThreshold(
    double indentThresholdValue,
  ) {
    return _setIndentThreshold(reference, indentThresholdValue).check();
  }

  static final _getDropThreshold = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getDropThreshold")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getDropThreshold()
  ///
  /// the minimum whitespace, as a multiple of the max height of the current characters beyond which the current line
  /// start is considered to be a paragraph start.
  ///@return the character height multiple for max allowed whitespace between lines in the same paragraph.
  double getDropThreshold() {
    return _getDropThreshold(reference).float;
  }

  static final _setDropThreshold = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("PDFTextStripper__setDropThreshold")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setDropThreshold(float dropThresholdValue)
  ///
  /// sets the minimum whitespace, as a multiple of the max height of the current characters beyond which the current
  /// line start is considered to be a paragraph start. The default value is 2.5.
  ///@param dropThresholdValue the character height multiple for max allowed whitespace between lines in the same
  /// paragraph.
  void setDropThreshold(
    double dropThresholdValue,
  ) {
    return _setDropThreshold(reference, dropThresholdValue).check();
  }

  static final _getParagraphStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getParagraphStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getParagraphStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the beginning of a paragraph.
  ///@return the paragraph start string
  jni.JString getParagraphStart() {
    return const jni.JStringType()
        .fromRef(_getParagraphStart(reference).object);
  }

  static final _setParagraphStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setParagraphStart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setParagraphStart(java.lang.String s)
  ///
  /// Sets the string which will be used at the beginning of a paragraph.
  ///@param s the paragraph start string
  void setParagraphStart(
    jni.JString s,
  ) {
    return _setParagraphStart(reference, s.reference).check();
  }

  static final _getParagraphEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getParagraphEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getParagraphEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the end of a paragraph.
  ///@return the paragraph end string
  jni.JString getParagraphEnd() {
    return const jni.JStringType().fromRef(_getParagraphEnd(reference).object);
  }

  static final _setParagraphEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setParagraphEnd")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setParagraphEnd(java.lang.String s)
  ///
  /// Sets the string which will be used at the end of a paragraph.
  ///@param s the paragraph end string
  void setParagraphEnd(
    jni.JString s,
  ) {
    return _setParagraphEnd(reference, s.reference).check();
  }

  static final _getPageStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getPageStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPageStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the beginning of a page.
  ///@return the page start string
  jni.JString getPageStart() {
    return const jni.JStringType().fromRef(_getPageStart(reference).object);
  }

  static final _setPageStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setPageStart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setPageStart(java.lang.String pageStartValue)
  ///
  /// Sets the string which will be used at the beginning of a page.
  ///@param pageStartValue the page start string
  void setPageStart(
    jni.JString pageStartValue,
  ) {
    return _setPageStart(reference, pageStartValue.reference).check();
  }

  static final _getPageEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getPageEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPageEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the end of a page.
  ///@return the page end string
  jni.JString getPageEnd() {
    return const jni.JStringType().fromRef(_getPageEnd(reference).object);
  }

  static final _setPageEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setPageEnd")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setPageEnd(java.lang.String pageEndValue)
  ///
  /// Sets the string which will be used at the end of a page.
  ///@param pageEndValue the page end string
  void setPageEnd(
    jni.JString pageEndValue,
  ) {
    return _setPageEnd(reference, pageEndValue.reference).check();
  }

  static final _getArticleStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getArticleStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getArticleStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the beginning of an article.
  ///@return the article start string
  jni.JString getArticleStart() {
    return const jni.JStringType().fromRef(_getArticleStart(reference).object);
  }

  static final _setArticleStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setArticleStart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setArticleStart(java.lang.String articleStartValue)
  ///
  /// Sets the string which will be used at the beginning of an article.
  ///@param articleStartValue the article start string
  void setArticleStart(
    jni.JString articleStartValue,
  ) {
    return _setArticleStart(reference, articleStartValue.reference).check();
  }

  static final _getArticleEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__getArticleEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getArticleEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string which will be used at the end of an article.
  ///@return the article end string
  jni.JString getArticleEnd() {
    return const jni.JStringType().fromRef(_getArticleEnd(reference).object);
  }

  static final _setArticleEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__setArticleEnd")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setArticleEnd(java.lang.String articleEndValue)
  ///
  /// Sets the string which will be used at the end of an article.
  ///@param articleEndValue the article end string
  void setArticleEnd(
    jni.JString articleEndValue,
  ) {
    return _setArticleEnd(reference, articleEndValue.reference).check();
  }

  static final _writeParagraphSeparator = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__writeParagraphSeparator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeParagraphSeparator()
  ///
  /// writes the paragraph separator string to the output.
  ///@throws IOException if something went wrong
  void writeParagraphSeparator() {
    return _writeParagraphSeparator(reference).check();
  }

  static final _writeParagraphStart = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__writeParagraphStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeParagraphStart()
  ///
  /// Write something (if defined) at the start of a paragraph.
  ///@throws IOException if something went wrong
  void writeParagraphStart() {
    return _writeParagraphStart(reference).check();
  }

  static final _writeParagraphEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writeParagraphEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writeParagraphEnd()
  ///
  /// Write something (if defined) at the end of a paragraph.
  ///@throws IOException if something went wrong
  void writeParagraphEnd() {
    return _writeParagraphEnd(reference).check();
  }

  static final _writePageStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writePageStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writePageStart()
  ///
  /// Write something (if defined) at the start of a page.
  ///@throws IOException if something went wrong
  void writePageStart() {
    return _writePageStart(reference).check();
  }

  static final _writePageEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__writePageEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void writePageEnd()
  ///
  /// Write something (if defined) at the end of a page.
  ///@throws IOException if something went wrong
  void writePageEnd() {
    return _writePageEnd(reference).check();
  }

  static final _setListItemPatterns = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__setListItemPatterns")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void setListItemPatterns(java.util.List<java.util.regex.Pattern> patterns)
  ///
  /// use to supply a different set of regular expression patterns for matching list item starts.
  ///@param patterns list of patterns
  void setListItemPatterns(
    jni.JObject patterns,
  ) {
    return _setListItemPatterns(reference, patterns.reference).check();
  }

  static final _getListItemPatterns = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PDFTextStripper__getListItemPatterns")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected java.util.List<java.util.regex.Pattern> getListItemPatterns()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// returns a list of regular expression Patterns representing different common list item formats. For example
  /// numbered items of form:
  /// <ol>
  /// <li>some text</li>
  /// <li>more text</li>
  /// </ol>
  /// or
  /// <ul>
  /// <li>some text</li>
  /// <li>more text</li>
  /// </ul>
  /// etc., all begin with some character pattern. The pattern "\\d+\." (matches "1.", "2.", ...) or "\[\\d+\]"
  /// (matches "[1]", "[2]", ...).
  ///
  /// This method returns a list of such regular expression Patterns.
  ///@return a list of Pattern objects.
  jni.JObject getListItemPatterns() {
    return const jni.JObjectType()
        .fromRef(_getListItemPatterns(reference).object);
  }

  static final _matchPattern = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PDFTextStripper__matchPattern")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static protected java.util.regex.Pattern matchPattern(java.lang.String string, java.util.List<java.util.regex.Pattern> patterns)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// iterates over the specified list of Patterns until it finds one that matches the specified string. Then returns
  /// the Pattern.
  ///
  /// Order of the supplied list of patterns is important as most common patterns should come first. Patterns should be
  /// strict in general, and all will be used with case sensitivity on.
  ///
  ///
  ///@param string the string to be searched
  ///@param patterns list of patterns
  ///@return matching pattern
  static jni.JObject matchPattern(
    jni.JString string,
    jni.JObject patterns,
  ) {
    return const jni.JObjectType()
        .fromRef(_matchPattern(string.reference, patterns.reference).object);
  }
}

class $PDFTextStripperType extends jni.JObjType<PDFTextStripper> {
  const $PDFTextStripperType();

  @override
  String get signature => r"Lorg/apache/pdfbox/text/PDFTextStripper;";

  @override
  PDFTextStripper fromRef(jni.JObjectPtr ref) => PDFTextStripper.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PDFTextStripperType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $PDFTextStripperType &&
        other is $PDFTextStripperType;
  }
}
