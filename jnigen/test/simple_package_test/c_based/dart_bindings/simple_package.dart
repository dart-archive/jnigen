// Copyright (c) 2022, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

// Auto-generated initialization code.

final ffi.Pointer<T> Function<T extends ffi.NativeType>(String sym) jniLookup =
    ProtectedJniExtensions.initGeneratedLibrary("simple_package");

/// from: com.github.dart_lang.jnigen.simple_package.Example
class Example extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  Example.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ExampleType();

  /// from: static public final int ON
  static const ON = 1;

  /// from: static public final int OFF
  static const OFF = 0;

  /// from: static public final double PI
  static const PI = 3.14159;

  /// from: static public final char SEMICOLON
  static const SEMICOLON = r""";""";

  /// from: static public final java.lang.String SEMICOLON_STRING
  static const SEMICOLON_STRING = r""";""";

  static final _get_amount =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Example__amount")
          .asFunction<jni.JniResult Function()>();

  static final _set_amount =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "set_Example__amount")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public int amount
  static int get amount => _get_amount().integer;

  /// from: static public int amount
  static set amount(int value) => _set_amount(value).check();

  static final _get_pi =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Example__pi")
          .asFunction<jni.JniResult Function()>();

  static final _set_pi =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Double)>>(
              "set_Example__pi")
          .asFunction<jni.JniResult Function(double)>();

  /// from: static public double pi
  static double get pi => _get_pi().doubleFloat;

  /// from: static public double pi
  static set pi(double value) => _set_pi(value).check();

  static final _get_asterisk =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Example__asterisk")
          .asFunction<jni.JniResult Function()>();

  static final _set_asterisk =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Uint16)>>(
              "set_Example__asterisk")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public char asterisk
  static int get asterisk => _get_asterisk().char;

  /// from: static public char asterisk
  static set asterisk(int value) => _set_asterisk(value).check();

  static final _get_name =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Example__name")
          .asFunction<jni.JniResult Function()>();

  static final _set_name = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("set_Example__name")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String name
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get name =>
      const jni.JStringType().fromRef(_get_name().object);

  /// from: static public java.lang.String name
  /// The returned object must be deleted after use, by calling the `delete` method.
  static set name(jni.JString value) => _set_name(value.reference).check();

  static final _get_aux =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Example__aux")
          .asFunction<jni.JniResult Function()>();

  static final _set_aux = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("set_Example__aux")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.simple_package.Example.Aux aux
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Example_Aux get aux =>
      const $Example_AuxType().fromRef(_get_aux().object);

  /// from: static public com.github.dart_lang.jnigen.simple_package.Example.Aux aux
  /// The returned object must be deleted after use, by calling the `delete` method.
  static set aux(Example_Aux value) => _set_aux(value.reference).check();

  static final _get_trillion = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_Example__trillion")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_trillion = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int64)>>("set_Example__trillion")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public long trillion
  int get trillion => _get_trillion(reference).long;

  /// from: public long trillion
  set trillion(int value) => _set_trillion(reference, value).check();

  static final _get_isAchillesDead = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_Example__isAchillesDead")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_isAchillesDead = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Uint8)>>("set_Example__isAchillesDead")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean isAchillesDead
  bool get isAchillesDead => _get_isAchillesDead(reference).boolean;

  /// from: public boolean isAchillesDead
  set isAchillesDead(bool value) =>
      _set_isAchillesDead(reference, value ? 1 : 0).check();

  static final _get_bestFighterInGreece = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_Example__bestFighterInGreece")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_bestFighterInGreece = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_Example__bestFighterInGreece")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String bestFighterInGreece
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString get bestFighterInGreece => const jni.JStringType()
      .fromRef(_get_bestFighterInGreece(reference).object);

  /// from: public java.lang.String bestFighterInGreece
  /// The returned object must be deleted after use, by calling the `delete` method.
  set bestFighterInGreece(jni.JString value) =>
      _set_bestFighterInGreece(reference, value.reference).check();

  static final _get_random = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_Example__random")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_random = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_Example__random")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Random random
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject get random =>
      const jni.JObjectType().fromRef(_get_random(reference).object);

  /// from: public java.util.Random random
  /// The returned object must be deleted after use, by calling the `delete` method.
  set random(jni.JObject value) =>
      _set_random(reference, value.reference).check();

  static final _get_num =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Example__num")
          .asFunction<jni.JniResult Function()>();

  static final _set_num =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "set_Example__num")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public int num
  static int get num => _get_num().integer;

  /// from: static public int num
  static set num(int value) => _set_num(value).check();

  static final _getAmount =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Example__getAmount")
          .asFunction<jni.JniResult Function()>();

  /// from: static public int getAmount()
  static int getAmount() {
    return _getAmount().integer;
  }

  static final _getPi =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example__getPi")
          .asFunction<jni.JniResult Function()>();

  /// from: static public double getPi()
  static double getPi() {
    return _getPi().doubleFloat;
  }

  static final _getAsterisk =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Example__getAsterisk")
          .asFunction<jni.JniResult Function()>();

  /// from: static public char getAsterisk()
  static int getAsterisk() {
    return _getAsterisk().char;
  }

  static final _getName =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Example__getName")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString getName() {
    return const jni.JStringType().fromRef(_getName().object);
  }

  static final _setAmount =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "Example__setAmount")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public void setAmount(int newAmount)
  static void setAmount(
    int newAmount,
  ) {
    return _setAmount(newAmount).check();
  }

  static final _setName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__setName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void setName(java.lang.String newName)
  static void setName(
    jni.JString newName,
  ) {
    return _setName(newName.reference).check();
  }

  static final _max4 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32)>>("Example__max4")
      .asFunction<jni.JniResult Function(int, int, int, int)>();

  /// from: static public int max4(int a, int b, int c, int d)
  static int max4(
    int a,
    int b,
    int c,
    int d,
  ) {
    return _max4(a, b, c, d).integer;
  }

  static final _max8 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32)>>("Example__max8")
      .asFunction<
          jni.JniResult Function(int, int, int, int, int, int, int, int)>();

  /// from: static public int max8(int a, int b, int c, int d, int e, int f, int g, int h)
  static int max8(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
  ) {
    return _max8(a, b, c, d, e, f, g, h).integer;
  }

  static final _getTrillion = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__getTrillion")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTrillion()
  int getTrillion() {
    return _getTrillion(reference).long;
  }

  static final _isAchillesAlive = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__isAchillesAlive")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAchillesAlive()
  bool isAchillesAlive() {
    return _isAchillesAlive(reference).boolean;
  }

  static final _whoIsBestFighterInGreece = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__whoIsBestFighterInGreece")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String whoIsBestFighterInGreece()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString whoIsBestFighterInGreece() {
    return const jni.JStringType()
        .fromRef(_whoIsBestFighterInGreece(reference).object);
  }

  static final _getRandom = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__getRandom")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Random getRandom()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject getRandom() {
    return const jni.JObjectType().fromRef(_getRandom(reference).object);
  }

  static final _getRandomLong = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__getRandomLong")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getRandomLong()
  int getRandomLong() {
    return _getRandomLong(reference).long;
  }

  static final _add4Longs = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64, ffi.Int64, ffi.Int64)>>("Example__add4Longs")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public long add4Longs(long a, long b, long c, long d)
  int add4Longs(
    int a,
    int b,
    int c,
    int d,
  ) {
    return _add4Longs(reference, a, b, c, d).long;
  }

  static final _add8Longs = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64)>>("Example__add8Longs")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int, int, int, int)>();

  /// from: public long add8Longs(long a, long b, long c, long d, long e, long f, long g, long h)
  int add8Longs(
    int a,
    int b,
    int c,
    int d,
    int e,
    int f,
    int g,
    int h,
  ) {
    return _add8Longs(reference, a, b, c, d, e, f, g, h).long;
  }

  static final _getRandomNumericString = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Example__getRandomNumericString")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getRandomNumericString(java.util.Random random)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getRandomNumericString(
    jni.JObject random,
  ) {
    return const jni.JStringType()
        .fromRef(_getRandomNumericString(reference, random.reference).object);
  }

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory Example() {
    return Example.fromRef(_ctor().object);
  }

  static final _ctor1 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "Example__ctor1")
          .asFunction<jni.JniResult Function(int)>();

  /// from: public void <init>(int internal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory Example.ctor1(
    int internal,
  ) {
    return Example.fromRef(_ctor1(internal).object);
  }

  static final _whichExample = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__whichExample")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int whichExample()
  int whichExample() {
    return _whichExample(reference).integer;
  }

  static final _getAux =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example__getAux")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.github.dart_lang.jnigen.simple_package.Example.Aux getAux()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Example_Aux getAux() {
    return const $Example_AuxType().fromRef(_getAux().object);
  }

  static final _addInts = jniLookup<
              ffi.NativeFunction<jni.JniResult Function(ffi.Int32, ffi.Int32)>>(
          "Example__addInts")
      .asFunction<jni.JniResult Function(int, int)>();

  /// from: static public int addInts(int a, int b)
  static int addInts(
    int a,
    int b,
  ) {
    return _addInts(a, b).integer;
  }

  static final _getArr =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example__getArr")
          .asFunction<jni.JniResult Function()>();

  /// from: static public int[] getArr()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<jni.JInt> getArr() {
    return const jni.JArrayType(jni.JIntType()).fromRef(_getArr().object);
  }

  static final _addAll = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Example__addAll")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public int addAll(int[] arr)
  static int addAll(
    jni.JArray<jni.JInt> arr,
  ) {
    return _addAll(arr.reference).integer;
  }

  static final _getSelf = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__getSelf")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.simple_package.Example getSelf()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Example getSelf() {
    return const $ExampleType().fromRef(_getSelf(reference).object);
  }

  static final _getNum = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Example__getNum")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getNum()
  int getNum() {
    return _getNum(reference).integer;
  }

  static final _setNum = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Example__setNum")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setNum(int num)
  void setNum(
    int num,
  ) {
    return _setNum(reference, num).check();
  }

  static final _getInternal = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__getInternal")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getInternal()
  int getInternal() {
    return _getInternal(reference).integer;
  }

  static final _setInternal = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Example__setInternal")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setInternal(int internal)
  void setInternal(
    int internal,
  ) {
    return _setInternal(reference, internal).check();
  }

  static final _throwException =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Example__throwException")
          .asFunction<jni.JniResult Function()>();

  /// from: static public void throwException()
  static void throwException() {
    return _throwException().check();
  }
}

class $ExampleType extends jni.JObjType<Example> {
  const $ExampleType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Example;";

  @override
  Example fromRef(jni.JObjectPtr ref) => Example.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExampleType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $ExampleType && other is $ExampleType;
  }
}

/// from: com.github.dart_lang.jnigen.simple_package.Example$Aux
class Example_Aux extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  Example_Aux.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Example_AuxType();
  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_Example_Aux__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Uint8)>>("set_Example_Aux__value")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean value
  bool get value => _get_value(reference).boolean;

  /// from: public boolean value
  set value(bool value) => _set_value(reference, value ? 1 : 0).check();

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Uint8)>>(
              "Example_Aux__ctor")
          .asFunction<jni.JniResult Function(int)>();

  /// from: public void <init>(boolean value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory Example_Aux(
    bool value,
  ) {
    return Example_Aux.fromRef(_ctor(value ? 1 : 0).object);
  }

  static final _getValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example_Aux__getValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getValue()
  bool getValue() {
    return _getValue(reference).boolean;
  }

  static final _setValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Example_Aux__setValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setValue(boolean value)
  void setValue(
    bool value,
  ) {
    return _setValue(reference, value ? 1 : 0).check();
  }
}

class $Example_AuxType extends jni.JObjType<Example_Aux> {
  const $Example_AuxType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Example$Aux;";

  @override
  Example_Aux fromRef(jni.JObjectPtr ref) => Example_Aux.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Example_AuxType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $Example_AuxType && other is $Example_AuxType;
  }
}

/// from: com.github.dart_lang.jnigen.pkg2.C2
class C2 extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  C2.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $C2Type();
  static final _get_CONSTANT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_C2__CONSTANT")
          .asFunction<jni.JniResult Function()>();

  static final _set_CONSTANT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "set_C2__CONSTANT")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public int CONSTANT
  static int get CONSTANT => _get_CONSTANT().integer;

  /// from: static public int CONSTANT
  static set CONSTANT(int value) => _set_CONSTANT(value).check();

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("C2__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory C2() {
    return C2.fromRef(_ctor().object);
  }
}

class $C2Type extends jni.JObjType<C2> {
  const $C2Type();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/pkg2/C2;";

  @override
  C2 fromRef(jni.JObjectPtr ref) => C2.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($C2Type).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $C2Type && other is $C2Type;
  }
}

/// from: com.github.dart_lang.jnigen.pkg2.Example
class Example1 extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  Example1.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Example1Type();
  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example1__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory Example1() {
    return Example1.fromRef(_ctor().object);
  }

  static final _whichExample = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example1__whichExample")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int whichExample()
  int whichExample() {
    return _whichExample(reference).integer;
  }
}

class $Example1Type extends jni.JObjType<Example1> {
  const $Example1Type();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/pkg2/Example;";

  @override
  Example1 fromRef(jni.JObjectPtr ref) => Example1.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Example1Type).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $Example1Type && other is $Example1Type;
  }
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent
class GrandParent<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType $type = type(T);

  final jni.JObjType<$T> T;

  GrandParent.fromRef(
    this.T,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $GrandParentType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $GrandParentType(
      T,
    );
  }

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_GrandParent__value")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public T value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $T get value => T.fromRef(_get_value(reference).object);

  /// from: public T value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($T value) => _set_value(reference, value.reference).check();

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("GrandParent__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(T value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory GrandParent(
    $T value, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$T>;
    return GrandParent.fromRef(T, _ctor(value.reference).object);
  }

  static final _stringParent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("GrandParent__stringParent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.generics.GrandParent<T>.Parent<java.lang.String> stringParent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  GrandParent_Parent<jni.JObject, jni.JString> stringParent() {
    return const $GrandParent_ParentType(jni.JObjectType(), jni.JStringType())
        .fromRef(_stringParent(reference).object);
  }

  static final _varParent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("GrandParent__varParent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.generics.GrandParent<T>.Parent<S> varParent(S nestedValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GrandParent_Parent<jni.JObject, $S> varParent<$S extends jni.JObject>(
    $S nestedValue, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      nestedValue.$type,
    ]) as jni.JObjType<$S>;
    return $GrandParent_ParentType(const jni.JObjectType(), S)
        .fromRef(_varParent(reference, nestedValue.reference).object);
  }

  static final _stringStaticParent =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "GrandParent__stringStaticParent")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<java.lang.String> stringStaticParent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static GrandParent_StaticParent<jni.JString> stringStaticParent() {
    return const $GrandParent_StaticParentType(jni.JStringType())
        .fromRef(_stringStaticParent().object);
  }

  static final _varStaticParent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("GrandParent__varStaticParent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<S> varStaticParent(S value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static GrandParent_StaticParent<$S> varStaticParent<$S extends jni.JObject>(
    $S value, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$S>;
    return $GrandParent_StaticParentType(S)
        .fromRef(_varStaticParent(value.reference).object);
  }

  static final _staticParentWithSameType = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "GrandParent__staticParentWithSameType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<T> staticParentWithSameType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  GrandParent_StaticParent<$T> staticParentWithSameType() {
    return $GrandParent_StaticParentType(T)
        .fromRef(_staticParentWithSameType(reference).object);
  }
}

class $GrandParentType<$T extends jni.JObject>
    extends jni.JObjType<GrandParent<$T>> {
  final jni.JObjType<$T> T;

  const $GrandParentType(
    this.T,
  );

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/GrandParent;";

  @override
  GrandParent<$T> fromRef(jni.JObjectPtr ref) => GrandParent.fromRef(T, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParentType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $GrandParentType &&
        other is $GrandParentType &&
        T == other.T;
  }
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$Parent
class GrandParent_Parent<$T extends jni.JObject, $S extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType $type = type(T, S);

  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;

  GrandParent_Parent.fromRef(
    this.T,
    this.S,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $GrandParent_ParentType<$T, $S>
      type<$T extends jni.JObject, $S extends jni.JObject>(
    jni.JObjType<$T> T,
    jni.JObjType<$S> S,
  ) {
    return $GrandParent_ParentType(
      T,
      S,
    );
  }

  static final _get_parentValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_Parent__parentValue")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_parentValue = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_Parent__parentValue")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public T parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  $T get parentValue => T.fromRef(_get_parentValue(reference).object);

  /// from: public T parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  set parentValue($T value) =>
      _set_parentValue(reference, value.reference).check();

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_Parent__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_GrandParent_Parent__value")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public S value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $S get value => S.fromRef(_get_value(reference).object);

  /// from: public S value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($S value) => _set_value(reference, value.reference).check();

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("GrandParent_Parent__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(T parentValue, S value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory GrandParent_Parent(
    $T parentValue,
    $S value, {
    jni.JObjType<$T>? T,
    jni.JObjType<$S>? S,
  }) {
    T ??= jni.lowestCommonSuperType([
      parentValue.$type,
    ]) as jni.JObjType<$T>;
    S ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$S>;
    return GrandParent_Parent.fromRef(
        T, S, _ctor(parentValue.reference, value.reference).object);
  }
}

class $GrandParent_ParentType<$T extends jni.JObject, $S extends jni.JObject>
    extends jni.JObjType<GrandParent_Parent<$T, $S>> {
  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;

  const $GrandParent_ParentType(
    this.T,
    this.S,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;";

  @override
  GrandParent_Parent<$T, $S> fromRef(jni.JObjectPtr ref) =>
      GrandParent_Parent.fromRef(T, S, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_ParentType, T, S);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $GrandParent_ParentType &&
        other is $GrandParent_ParentType &&
        T == other.T &&
        S == other.S;
  }
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$Parent$Child
class GrandParent_Parent_Child<$T extends jni.JObject, $S extends jni.JObject,
    $U extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType $type = type(T, S, U);

  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  GrandParent_Parent_Child.fromRef(
    this.T,
    this.S,
    this.U,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $GrandParent_Parent_ChildType<$T, $S, $U> type<$T extends jni.JObject,
      $S extends jni.JObject, $U extends jni.JObject>(
    jni.JObjType<$T> T,
    jni.JObjType<$S> S,
    jni.JObjType<$U> U,
  ) {
    return $GrandParent_Parent_ChildType(
      T,
      S,
      U,
    );
  }

  static final _get_grandParentValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_Parent_Child__grandParentValue")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_grandParentValue = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_Parent_Child__grandParentValue")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public T grandParentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  $T get grandParentValue => T.fromRef(_get_grandParentValue(reference).object);

  /// from: public T grandParentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  set grandParentValue($T value) =>
      _set_grandParentValue(reference, value.reference).check();

  static final _get_parentValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_Parent_Child__parentValue")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_parentValue = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_Parent_Child__parentValue")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public S parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  $S get parentValue => S.fromRef(_get_parentValue(reference).object);

  /// from: public S parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  set parentValue($S value) =>
      _set_parentValue(reference, value.reference).check();

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_Parent_Child__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_Parent_Child__value")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public U value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $U get value => U.fromRef(_get_value(reference).object);

  /// from: public U value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($U value) => _set_value(reference, value.reference).check();

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("GrandParent_Parent_Child__ctor")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(T grandParentValue, S parentValue, U value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory GrandParent_Parent_Child(
    $T grandParentValue,
    $S parentValue,
    $U value, {
    jni.JObjType<$T>? T,
    jni.JObjType<$S>? S,
    jni.JObjType<$U>? U,
  }) {
    T ??= jni.lowestCommonSuperType([
      grandParentValue.$type,
    ]) as jni.JObjType<$T>;
    S ??= jni.lowestCommonSuperType([
      parentValue.$type,
    ]) as jni.JObjType<$S>;
    U ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$U>;
    return GrandParent_Parent_Child.fromRef(
        T,
        S,
        U,
        _ctor(grandParentValue.reference, parentValue.reference,
                value.reference)
            .object);
  }
}

class $GrandParent_Parent_ChildType<$T extends jni.JObject,
        $S extends jni.JObject, $U extends jni.JObject>
    extends jni.JObjType<GrandParent_Parent_Child<$T, $S, $U>> {
  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  const $GrandParent_Parent_ChildType(
    this.T,
    this.S,
    this.U,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent$Child;";

  @override
  GrandParent_Parent_Child<$T, $S, $U> fromRef(jni.JObjectPtr ref) =>
      GrandParent_Parent_Child.fromRef(T, S, U, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_Parent_ChildType, T, S, U);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $GrandParent_Parent_ChildType &&
        other is $GrandParent_Parent_ChildType &&
        T == other.T &&
        S == other.S &&
        U == other.U;
  }
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$StaticParent
class GrandParent_StaticParent<$S extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType $type = type(S);

  final jni.JObjType<$S> S;

  GrandParent_StaticParent.fromRef(
    this.S,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParentType<$S> type<$S extends jni.JObject>(
    jni.JObjType<$S> S,
  ) {
    return $GrandParent_StaticParentType(
      S,
    );
  }

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_StaticParent__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_StaticParent__value")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public S value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $S get value => S.fromRef(_get_value(reference).object);

  /// from: public S value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($S value) => _set_value(reference, value.reference).check();

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("GrandParent_StaticParent__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(S value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory GrandParent_StaticParent(
    $S value, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$S>;
    return GrandParent_StaticParent.fromRef(S, _ctor(value.reference).object);
  }
}

class $GrandParent_StaticParentType<$S extends jni.JObject>
    extends jni.JObjType<GrandParent_StaticParent<$S>> {
  final jni.JObjType<$S> S;

  const $GrandParent_StaticParentType(
    this.S,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;";

  @override
  GrandParent_StaticParent<$S> fromRef(jni.JObjectPtr ref) =>
      GrandParent_StaticParent.fromRef(S, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_StaticParentType, S);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $GrandParent_StaticParentType &&
        other is $GrandParent_StaticParentType &&
        S == other.S;
  }
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$StaticParent$Child
class GrandParent_StaticParent_Child<$S extends jni.JObject,
    $U extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType $type = type(S, U);

  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  GrandParent_StaticParent_Child.fromRef(
    this.S,
    this.U,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParent_ChildType<$S, $U>
      type<$S extends jni.JObject, $U extends jni.JObject>(
    jni.JObjType<$S> S,
    jni.JObjType<$U> U,
  ) {
    return $GrandParent_StaticParent_ChildType(
      S,
      U,
    );
  }

  static final _get_parentValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_StaticParent_Child__parentValue")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_parentValue = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_StaticParent_Child__parentValue")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public S parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  $S get parentValue => S.fromRef(_get_parentValue(reference).object);

  /// from: public S parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  set parentValue($S value) =>
      _set_parentValue(reference, value.reference).check();

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_StaticParent_Child__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_StaticParent_Child__value")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public U value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $U get value => U.fromRef(_get_value(reference).object);

  /// from: public U value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($U value) => _set_value(reference, value.reference).check();

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "GrandParent_StaticParent_Child__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(S parentValue, U value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory GrandParent_StaticParent_Child(
    $S parentValue,
    $U value, {
    jni.JObjType<$S>? S,
    jni.JObjType<$U>? U,
  }) {
    S ??= jni.lowestCommonSuperType([
      parentValue.$type,
    ]) as jni.JObjType<$S>;
    U ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$U>;
    return GrandParent_StaticParent_Child.fromRef(
        S, U, _ctor(parentValue.reference, value.reference).object);
  }
}

class $GrandParent_StaticParent_ChildType<$S extends jni.JObject,
        $U extends jni.JObject>
    extends jni.JObjType<GrandParent_StaticParent_Child<$S, $U>> {
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  const $GrandParent_StaticParent_ChildType(
    this.S,
    this.U,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child;";

  @override
  GrandParent_StaticParent_Child<$S, $U> fromRef(jni.JObjectPtr ref) =>
      GrandParent_StaticParent_Child.fromRef(S, U, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($GrandParent_StaticParent_ChildType, S, U);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $GrandParent_StaticParent_ChildType &&
        other is $GrandParent_StaticParent_ChildType &&
        S == other.S &&
        U == other.U;
  }
}

/// from: com.github.dart_lang.jnigen.generics.MyMap
class MyMap<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType $type = type(K, V);

  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  MyMap.fromRef(
    this.K,
    this.V,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $MyMapType<$K, $V>
      type<$K extends jni.JObject, $V extends jni.JObject>(
    jni.JObjType<$K> K,
    jni.JObjType<$V> V,
  ) {
    return $MyMapType(
      K,
      V,
    );
  }

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("MyMap__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory MyMap({
    required jni.JObjType<$K> K,
    required jni.JObjType<$V> V,
  }) {
    return MyMap.fromRef(K, V, _ctor().object);
  }

  static final _get0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("MyMap__get0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public V get(K key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  $V get0(
    $K key,
  ) {
    return V.fromRef(_get0(reference, key.reference).object);
  }

  static final _put = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("MyMap__put")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public V put(K key, V value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  $V put(
    $K key,
    $V value,
  ) {
    return V.fromRef(_put(reference, key.reference, value.reference).object);
  }

  static final _entryStack = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("MyMap__entryStack")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.generics.MyStack<com.github.dart_lang.jnigen.generics.MyMap<K,V>.MyEntry> entryStack()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MyStack<MyMap_MyEntry<jni.JObject, jni.JObject>> entryStack() {
    return const $MyStackType(
            $MyMap_MyEntryType(jni.JObjectType(), jni.JObjectType()))
        .fromRef(_entryStack(reference).object);
  }
}

class $MyMapType<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObjType<MyMap<$K, $V>> {
  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  const $MyMapType(
    this.K,
    this.V,
  );

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/MyMap;";

  @override
  MyMap<$K, $V> fromRef(jni.JObjectPtr ref) => MyMap.fromRef(K, V, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($MyMapType, K, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $MyMapType &&
        other is $MyMapType &&
        K == other.K &&
        V == other.V;
  }
}

/// from: com.github.dart_lang.jnigen.generics.MyMap$MyEntry
class MyMap_MyEntry<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObject {
  @override
  late final jni.JObjType $type = type(K, V);

  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  MyMap_MyEntry.fromRef(
    this.K,
    this.V,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $MyMap_MyEntryType<$K, $V>
      type<$K extends jni.JObject, $V extends jni.JObject>(
    jni.JObjType<$K> K,
    jni.JObjType<$V> V,
  ) {
    return $MyMap_MyEntryType(
      K,
      V,
    );
  }

  static final _get_key = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_MyMap_MyEntry__key")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_key = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_MyMap_MyEntry__key")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public K key
  /// The returned object must be deleted after use, by calling the `delete` method.
  $K get key => K.fromRef(_get_key(reference).object);

  /// from: public K key
  /// The returned object must be deleted after use, by calling the `delete` method.
  set key($K value) => _set_key(reference, value.reference).check();

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_MyMap_MyEntry__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_MyMap_MyEntry__value")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public V value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $V get value => V.fromRef(_get_value(reference).object);

  /// from: public V value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($V value) => _set_value(reference, value.reference).check();

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MyMap_MyEntry__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(K key, V value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory MyMap_MyEntry(
    $K key,
    $V value, {
    jni.JObjType<$K>? K,
    jni.JObjType<$V>? V,
  }) {
    K ??= jni.lowestCommonSuperType([
      key.$type,
    ]) as jni.JObjType<$K>;
    V ??= jni.lowestCommonSuperType([
      value.$type,
    ]) as jni.JObjType<$V>;
    return MyMap_MyEntry.fromRef(
        K, V, _ctor(key.reference, value.reference).object);
  }
}

class $MyMap_MyEntryType<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObjType<MyMap_MyEntry<$K, $V>> {
  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  const $MyMap_MyEntryType(
    this.K,
    this.V,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/MyMap$MyEntry;";

  @override
  MyMap_MyEntry<$K, $V> fromRef(jni.JObjectPtr ref) =>
      MyMap_MyEntry.fromRef(K, V, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($MyMap_MyEntryType, K, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $MyMap_MyEntryType &&
        other is $MyMap_MyEntryType &&
        K == other.K &&
        V == other.V;
  }
}

/// from: com.github.dart_lang.jnigen.generics.MyStack
class MyStack<$T extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType $type = type(T);

  final jni.JObjType<$T> T;

  MyStack.fromRef(
    this.T,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $MyStackType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $MyStackType(
      T,
    );
  }

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("MyStack__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory MyStack({
    required jni.JObjType<$T> T,
  }) {
    return MyStack.fromRef(T, _ctor().object);
  }

  static final _fromArray = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("MyStack__fromArray")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<T> fromArray(T[] arr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static MyStack<$T> fromArray<$T extends jni.JObject>(
    jni.JArray<$T> arr, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      ((arr.$type as jni.JArrayType).elementType as jni.JObjType),
    ]) as jni.JObjType<$T>;
    return $MyStackType(T).fromRef(_fromArray(arr.reference).object);
  }

  static final _fromArrayOfArrayOfGrandParents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MyStack__fromArrayOfArrayOfGrandParents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<S> fromArrayOfArrayOfGrandParents(com.github.dart_lang.jnigen.generics.GrandParent<S>[][] arr)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static MyStack<$S> fromArrayOfArrayOfGrandParents<$S extends jni.JObject>(
    jni.JArray<jni.JArray<GrandParent<$S>>> arr, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.lowestCommonSuperType([
      (((((arr.$type as jni.JArrayType).elementType as jni.JObjType)
                  as jni.JArrayType)
              .elementType as jni.JObjType) as $GrandParentType)
          .T,
    ]) as jni.JObjType<$S>;
    return $MyStackType(S)
        .fromRef(_fromArrayOfArrayOfGrandParents(arr.reference).object);
  }

  static final _of =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("MyStack__of")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<T> of()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static MyStack<$T> of<$T extends jni.JObject>({
    required jni.JObjType<$T> T,
  }) {
    return $MyStackType(T).fromRef(_of().object);
  }

  static final _of1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("MyStack__of1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T obj)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static MyStack<$T> of1<$T extends jni.JObject>(
    $T obj, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      obj.$type,
    ]) as jni.JObjType<$T>;
    return $MyStackType(T).fromRef(_of1(obj.reference).object);
  }

  static final _of2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MyStack__of2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T obj, T obj2)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static MyStack<$T> of2<$T extends jni.JObject>(
    $T obj,
    $T obj2, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      obj2.$type,
      obj.$type,
    ]) as jni.JObjType<$T>;
    return $MyStackType(T).fromRef(_of2(obj.reference, obj2.reference).object);
  }

  static final _push = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MyStack__push")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void push(T item)
  void push(
    $T item,
  ) {
    return _push(reference, item.reference).check();
  }

  static final _pop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("MyStack__pop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public T pop()
  /// The returned object must be deleted after use, by calling the `delete` method.
  $T pop() {
    return T.fromRef(_pop(reference).object);
  }

  static final _size = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("MyStack__size")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int size()
  int size() {
    return _size(reference).integer;
  }
}

class $MyStackType<$T extends jni.JObject> extends jni.JObjType<MyStack<$T>> {
  final jni.JObjType<$T> T;

  const $MyStackType(
    this.T,
  );

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/MyStack;";

  @override
  MyStack<$T> fromRef(jni.JObjectPtr ref) => MyStack.fromRef(T, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($MyStackType, T);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $MyStackType &&
        other is $MyStackType &&
        T == other.T;
  }
}

/// from: com.github.dart_lang.jnigen.generics.StringKeyedMap
class StringKeyedMap<$V extends jni.JObject> extends MyMap<jni.JString, $V> {
  @override
  late final jni.JObjType $type = type(V);

  final jni.JObjType<$V> V;

  StringKeyedMap.fromRef(
    this.V,
    jni.JObjectPtr ref,
  ) : super.fromRef(const jni.JStringType(), V, ref);

  /// The type which includes information such as the signature of this class.
  static $StringKeyedMapType<$V> type<$V extends jni.JObject>(
    jni.JObjType<$V> V,
  ) {
    return $StringKeyedMapType(
      V,
    );
  }

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "StringKeyedMap__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory StringKeyedMap({
    required jni.JObjType<$V> V,
  }) {
    return StringKeyedMap.fromRef(V, _ctor().object);
  }
}

class $StringKeyedMapType<$V extends jni.JObject>
    extends jni.JObjType<StringKeyedMap<$V>> {
  final jni.JObjType<$V> V;

  const $StringKeyedMapType(
    this.V,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/StringKeyedMap;";

  @override
  StringKeyedMap<$V> fromRef(jni.JObjectPtr ref) =>
      StringKeyedMap.fromRef(V, ref);

  @override
  jni.JObjType get superType => $MyMapType(const jni.JStringType(), V);

  @override
  final superCount = 2;

  @override
  int get hashCode => Object.hash($StringKeyedMapType, V);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $StringKeyedMapType &&
        other is $StringKeyedMapType &&
        V == other.V;
  }
}

/// from: com.github.dart_lang.jnigen.generics.StringMap
class StringMap extends StringKeyedMap<jni.JString> {
  @override
  late final jni.JObjType $type = type;

  StringMap.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(const jni.JStringType(), ref);

  /// The type which includes information such as the signature of this class.
  static const type = $StringMapType();
  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("StringMap__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory StringMap() {
    return StringMap.fromRef(_ctor().object);
  }
}

class $StringMapType extends jni.JObjType<StringMap> {
  const $StringMapType();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/StringMap;";

  @override
  StringMap fromRef(jni.JObjectPtr ref) => StringMap.fromRef(ref);

  @override
  jni.JObjType get superType => const $StringKeyedMapType(jni.JStringType());

  @override
  final superCount = 3;

  @override
  int get hashCode => ($StringMapType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $StringMapType && other is $StringMapType;
  }
}

/// from: com.github.dart_lang.jnigen.generics.StringStack
class StringStack extends MyStack<jni.JString> {
  @override
  late final jni.JObjType $type = type;

  StringStack.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(const jni.JStringType(), ref);

  /// The type which includes information such as the signature of this class.
  static const type = $StringStackType();
  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "StringStack__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory StringStack() {
    return StringStack.fromRef(_ctor().object);
  }
}

class $StringStackType extends jni.JObjType<StringStack> {
  const $StringStackType();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/StringStack;";

  @override
  StringStack fromRef(jni.JObjectPtr ref) => StringStack.fromRef(ref);

  @override
  jni.JObjType get superType => const $MyStackType(jni.JStringType());

  @override
  final superCount = 2;

  @override
  int get hashCode => ($StringStackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $StringStackType && other is $StringStackType;
  }
}

/// from: com.github.dart_lang.jnigen.generics.StringValuedMap
class StringValuedMap<$K extends jni.JObject> extends MyMap<$K, jni.JString> {
  @override
  late final jni.JObjType $type = type(K);

  final jni.JObjType<$K> K;

  StringValuedMap.fromRef(
    this.K,
    jni.JObjectPtr ref,
  ) : super.fromRef(K, const jni.JStringType(), ref);

  /// The type which includes information such as the signature of this class.
  static $StringValuedMapType<$K> type<$K extends jni.JObject>(
    jni.JObjType<$K> K,
  ) {
    return $StringValuedMapType(
      K,
    );
  }

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "StringValuedMap__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory StringValuedMap({
    required jni.JObjType<$K> K,
  }) {
    return StringValuedMap.fromRef(K, _ctor().object);
  }
}

class $StringValuedMapType<$K extends jni.JObject>
    extends jni.JObjType<StringValuedMap<$K>> {
  final jni.JObjType<$K> K;

  const $StringValuedMapType(
    this.K,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/StringValuedMap;";

  @override
  StringValuedMap<$K> fromRef(jni.JObjectPtr ref) =>
      StringValuedMap.fromRef(K, ref);

  @override
  jni.JObjType get superType => $MyMapType(K, const jni.JStringType());

  @override
  final superCount = 2;

  @override
  int get hashCode => Object.hash($StringValuedMapType, K);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $StringValuedMapType &&
        other is $StringValuedMapType &&
        K == other.K;
  }
}

/// from: com.github.dart_lang.jnigen.annotations.JsonSerializable$Case
class JsonSerializable_Case extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  JsonSerializable_Case.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $JsonSerializable_CaseType();
  static final _values =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "JsonSerializable_Case__values")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.github.dart_lang.jnigen.annotations.JsonSerializable.Case[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<JsonSerializable_Case> values() {
    return const jni.JArrayType($JsonSerializable_CaseType())
        .fromRef(_values().object);
  }

  static final _valueOf = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("JsonSerializable_Case__valueOf")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.annotations.JsonSerializable.Case valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static JsonSerializable_Case valueOf(
    jni.JString name,
  ) {
    return const $JsonSerializable_CaseType()
        .fromRef(_valueOf(name.reference).object);
  }
}

class $JsonSerializable_CaseType extends jni.JObjType<JsonSerializable_Case> {
  const $JsonSerializable_CaseType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;";

  @override
  JsonSerializable_Case fromRef(jni.JObjectPtr ref) =>
      JsonSerializable_Case.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($JsonSerializable_CaseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $JsonSerializable_CaseType &&
        other is $JsonSerializable_CaseType;
  }
}

/// from: com.github.dart_lang.jnigen.annotations.MyDataClass
class MyDataClass extends jni.JObject {
  @override
  late final jni.JObjType $type = type;

  MyDataClass.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $MyDataClassType();
  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "MyDataClass__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory MyDataClass() {
    return MyDataClass.fromRef(_ctor().object);
  }
}

class $MyDataClassType extends jni.JObjType<MyDataClass> {
  const $MyDataClassType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/annotations/MyDataClass;";

  @override
  MyDataClass fromRef(jni.JObjectPtr ref) => MyDataClass.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MyDataClassType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == $MyDataClassType && other is $MyDataClassType;
  }
}
