// Copyright (c) 2022, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_import

import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

// Auto-generated initialization code.

final ffi.Pointer<T> Function<T extends ffi.NativeType>(String sym) jniLookup =
    ProtectedJniExtensions.initGeneratedLibrary("simple_package");

/// from: com.github.dart_lang.jnigen.simple_package.Example
class Example extends jni.JObject {
  final $ExampleType $type;

  Example.fromRef(
    jni.JObjectPtr ref,
  )   : $type = type,
        super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ExampleType();

  /// from: static public final int ON
  static const ON = 1;

  /// from: static public final int OFF
  static const OFF = 0;

  static final _get_aux =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Example__aux")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.github.dart_lang.jnigen.simple_package.Example.Aux aux
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Example_Aux get aux =>
      const $Example_AuxType().fromRef(_get_aux().object);
  static final _set_aux = jniLookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>)>>("set_Example__aux")
      .asFunction<jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.simple_package.Example.Aux aux
  /// The returned object must be deleted after use, by calling the `delete` method.
  static set aux(Example_Aux value) => _set_aux(value.reference);

  static final _get_num =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Example__num")
          .asFunction<jni.JniResult Function()>();

  /// from: static public int num
  static int get num => _get_num().integer;
  static final _set_num =
      jniLookup<ffi.NativeFunction<jni.JThrowablePtr Function(ffi.Int32)>>(
              "set_Example__num")
          .asFunction<jni.JThrowablePtr Function(int)>();

  /// from: static public int num
  static set num(int value) => _set_num(value);

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Example()
      : $type = $ExampleType(),
        super.fromRef(_ctor().object);

  static final _whichExample = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__whichExample")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int whichExample()
  int whichExample() => _whichExample(reference).integer;

  static final _getAux =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example__getAux")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.github.dart_lang.jnigen.simple_package.Example.Aux getAux()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Example_Aux getAux() =>
      const $Example_AuxType().fromRef(_getAux().object);

  static final _addInts = jniLookup<
              ffi.NativeFunction<jni.JniResult Function(ffi.Int32, ffi.Int32)>>(
          "Example__addInts")
      .asFunction<jni.JniResult Function(int, int)>();

  /// from: static public int addInts(int a, int b)
  static int addInts(int a, int b) => _addInts(a, b).integer;

  static final _getArr =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example__getArr")
          .asFunction<jni.JniResult Function()>();

  /// from: static public int[] getArr()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<jni.JInt> getArr() =>
      const jni.JArrayType(jni.JIntType()).fromRef(_getArr().object);

  static final _addAll = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Example__addAll")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public int addAll(int[] arr)
  static int addAll(jni.JArray<jni.JInt> arr) => _addAll(arr.reference).integer;

  static final _getSelf = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__getSelf")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.simple_package.Example getSelf()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Example getSelf() => const $ExampleType().fromRef(_getSelf(reference).object);

  static final _getNum = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Example__getNum")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getNum()
  int getNum() => _getNum(reference).integer;

  static final _setNum = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Example__setNum")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setNum(int num)
  void setNum(int num) => _setNum(reference, num).check();

  static final _getInternal = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__getInternal")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getInternal()
  int getInternal() => _getInternal(reference).integer;

  static final _setInternal = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Example__setInternal")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setInternal(int internal)
  void setInternal(int internal) => _setInternal(reference, internal).check();

  static final _throwException =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Example__throwException")
          .asFunction<jni.JniResult Function()>();

  /// from: static public void throwException()
  static void throwException() => _throwException().check();
}

class $ExampleType extends jni.JObjType<Example> {
  const $ExampleType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Example;";

  @override
  Example fromRef(jni.JObjectPtr ref) => Example.fromRef(ref);
}

extension $ExampleArray on jni.JArray<Example> {
  Example operator [](int index) {
    return ($type.elementType as $ExampleType)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, Example value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}

/// from: com.github.dart_lang.jnigen.simple_package.Example$Aux
class Example_Aux extends jni.JObject {
  final $Example_AuxType $type;

  Example_Aux.fromRef(
    jni.JObjectPtr ref,
  )   : $type = type,
        super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Example_AuxType();

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_Example_Aux__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  /// from: public boolean value
  bool get value => _get_value(reference).boolean;
  static final _set_value = jniLookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  jni.JObjectPtr, ffi.Uint8)>>("set_Example_Aux__value")
      .asFunction<jni.JThrowablePtr Function(jni.JObjectPtr, int)>();

  /// from: public boolean value
  set value(bool value) => _set_value(reference, value ? 1 : 0);

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Uint8)>>(
              "Example_Aux__ctor")
          .asFunction<jni.JniResult Function(int)>();

  /// from: public void <init>(boolean value)
  Example_Aux(bool value)
      : $type = $Example_AuxType(),
        super.fromRef(_ctor(value ? 1 : 0).object);

  static final _getValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example_Aux__getValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getValue()
  bool getValue() => _getValue(reference).boolean;

  static final _setValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Example_Aux__setValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setValue(boolean value)
  void setValue(bool value) => _setValue(reference, value ? 1 : 0).check();
}

class $Example_AuxType extends jni.JObjType<Example_Aux> {
  const $Example_AuxType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Example$Aux;";

  @override
  Example_Aux fromRef(jni.JObjectPtr ref) => Example_Aux.fromRef(ref);
}

extension $Example_AuxArray on jni.JArray<Example_Aux> {
  Example_Aux operator [](int index) {
    return ($type.elementType as $Example_AuxType)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, Example_Aux value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}

/// from: com.github.dart_lang.jnigen.pkg2.C2
class C2 extends jni.JObject {
  final $C2Type $type;

  C2.fromRef(
    jni.JObjectPtr ref,
  )   : $type = type,
        super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $C2Type();

  static final _get_CONSTANT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_C2__CONSTANT")
          .asFunction<jni.JniResult Function()>();

  /// from: static public int CONSTANT
  static int get CONSTANT => _get_CONSTANT().integer;
  static final _set_CONSTANT =
      jniLookup<ffi.NativeFunction<jni.JThrowablePtr Function(ffi.Int32)>>(
              "set_C2__CONSTANT")
          .asFunction<jni.JThrowablePtr Function(int)>();

  /// from: static public int CONSTANT
  static set CONSTANT(int value) => _set_CONSTANT(value);

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("C2__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  C2()
      : $type = $C2Type(),
        super.fromRef(_ctor().object);
}

class $C2Type extends jni.JObjType<C2> {
  const $C2Type();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/pkg2/C2;";

  @override
  C2 fromRef(jni.JObjectPtr ref) => C2.fromRef(ref);
}

extension $C2Array on jni.JArray<C2> {
  C2 operator [](int index) {
    return ($type.elementType as $C2Type)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, C2 value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}

/// from: com.github.dart_lang.jnigen.pkg2.Example
class Example1 extends jni.JObject {
  final $Example1Type $type;

  Example1.fromRef(
    jni.JObjectPtr ref,
  )   : $type = type,
        super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Example1Type();

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example1__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Example1()
      : $type = $Example1Type(),
        super.fromRef(_ctor().object);

  static final _whichExample = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example1__whichExample")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int whichExample()
  int whichExample() => _whichExample(reference).integer;
}

class $Example1Type extends jni.JObjType<Example1> {
  const $Example1Type();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/pkg2/Example;";

  @override
  Example1 fromRef(jni.JObjectPtr ref) => Example1.fromRef(ref);
}

extension $Example1Array on jni.JArray<Example1> {
  Example1 operator [](int index) {
    return ($type.elementType as $Example1Type)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, Example1 value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}

/// from: com.github.dart_lang.jnigen.generics.MyMap
class MyMap<K extends jni.JObject, V extends jni.JObject> extends jni.JObject {
  final $MyMapType<K, V> $type;

  final jni.JObjType<K> $K;
  final jni.JObjType<V> $V;

  MyMap.fromRef(
    this.$K,
    this.$V,
    jni.JObjectPtr ref,
  )   : $type = type(
          $K,
          $V,
        ),
        super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $MyMapType<K, V> type<K extends jni.JObject, V extends jni.JObject>(
    jni.JObjType<K> $K,
    jni.JObjType<V> $V,
  ) {
    return $MyMapType(
      $K,
      $V,
    );
  }

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("MyMap__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  MyMap(this.$K, this.$V)
      : $type = $MyMapType(
          $K,
          $V,
        ),
        super.fromRef(_ctor().object);

  static final _get0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("MyMap__get0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public V get(K key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V get0(K key) => $V.fromRef(_get0(reference, key.reference).object);

  static final _put = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("MyMap__put")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public V put(K key, V value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V put(K key, V value) =>
      $V.fromRef(_put(reference, key.reference, value.reference).object);

  static final _remove = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MyMap__remove")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public V remove(K key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V remove(K key) => $V.fromRef(_remove(reference, key.reference).object);

  static final _entryArray = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("MyMap__entryArray")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.generics.MyMap<K,V>.MyEntry[] entryArray()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JArray<MyMap_MyEntry<K, V>> entryArray() =>
      jni.JArrayType($MyMap_MyEntryType($K, $V))
          .fromRef(_entryArray(reference).object);
}

class $MyMapType<K extends jni.JObject, V extends jni.JObject>
    extends jni.JObjType<MyMap<K, V>> {
  final jni.JObjType<K> $K;
  final jni.JObjType<V> $V;

  const $MyMapType(
    this.$K,
    this.$V,
  );

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/MyMap;";

  @override
  MyMap<K, V> fromRef(jni.JObjectPtr ref) => MyMap.fromRef($K, $V, ref);
}

extension $MyMapArray<K extends jni.JObject, V extends jni.JObject>
    on jni.JArray<MyMap<K, V>> {
  MyMap<K, V> operator [](int index) {
    return ($type.elementType as $MyMapType<K, V>)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, MyMap<K, V> value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}

/// from: com.github.dart_lang.jnigen.generics.MyMap$MyEntry
class MyMap_MyEntry<K extends jni.JObject, V extends jni.JObject>
    extends jni.JObject {
  final $MyMap_MyEntryType<K, V> $type;

  final jni.JObjType<K> $K;
  final jni.JObjType<V> $V;

  MyMap_MyEntry.fromRef(
    this.$K,
    this.$V,
    jni.JObjectPtr ref,
  )   : $type = type(
          $K,
          $V,
        ),
        super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $MyMap_MyEntryType<K, V>
      type<K extends jni.JObject, V extends jni.JObject>(
    jni.JObjType<K> $K,
    jni.JObjType<V> $V,
  ) {
    return $MyMap_MyEntryType(
      $K,
      $V,
    );
  }

  static final _get_key = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_MyMap_MyEntry__key")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  /// from: public K key
  /// The returned object must be deleted after use, by calling the `delete` method.
  K get key => $K.fromRef(_get_key(reference).object);
  static final _set_key = jniLookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_MyMap_MyEntry__key")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public K key
  /// The returned object must be deleted after use, by calling the `delete` method.
  set key(K value) => _set_key(reference, value.reference);

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_MyMap_MyEntry__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  /// from: public V value
  /// The returned object must be deleted after use, by calling the `delete` method.
  V get value => $V.fromRef(_get_value(reference).object);
  static final _set_value = jniLookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_MyMap_MyEntry__value")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public V value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value(V value) => _set_value(reference, value.reference);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MyMap_MyEntry__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(K key, V value)
  MyMap_MyEntry(this.$K, this.$V, K key, V value)
      : $type = $MyMap_MyEntryType(
          $K,
          $V,
        ),
        super.fromRef(_ctor(key.reference, value.reference).object);
}

class $MyMap_MyEntryType<K extends jni.JObject, V extends jni.JObject>
    extends jni.JObjType<MyMap_MyEntry<K, V>> {
  final jni.JObjType<K> $K;
  final jni.JObjType<V> $V;

  const $MyMap_MyEntryType(
    this.$K,
    this.$V,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/MyMap$MyEntry;";

  @override
  MyMap_MyEntry<K, V> fromRef(jni.JObjectPtr ref) =>
      MyMap_MyEntry.fromRef($K, $V, ref);
}

extension $MyMap_MyEntryArray<K extends jni.JObject, V extends jni.JObject>
    on jni.JArray<MyMap_MyEntry<K, V>> {
  MyMap_MyEntry<K, V> operator [](int index) {
    return ($type.elementType as $MyMap_MyEntryType<K, V>)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, MyMap_MyEntry<K, V> value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}

/// from: com.github.dart_lang.jnigen.generics.MyStack
class MyStack<T extends jni.JObject> extends jni.JObject {
  final $MyStackType<T> $type;

  final jni.JObjType<T> $T;

  MyStack.fromRef(
    this.$T,
    jni.JObjectPtr ref,
  )   : $type = type(
          $T,
        ),
        super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $MyStackType<T> type<T extends jni.JObject>(
    jni.JObjType<T> $T,
  ) {
    return $MyStackType(
      $T,
    );
  }

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("MyStack__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  MyStack(this.$T)
      : $type = $MyStackType(
          $T,
        ),
        super.fromRef(_ctor().object);

  static final _push = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MyStack__push")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void push(T item)
  void push(T item) => _push(reference, item.reference).check();

  static final _pop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("MyStack__pop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public T pop()
  /// The returned object must be deleted after use, by calling the `delete` method.
  T pop() => $T.fromRef(_pop(reference).object);
}

class $MyStackType<T extends jni.JObject> extends jni.JObjType<MyStack<T>> {
  final jni.JObjType<T> $T;

  const $MyStackType(
    this.$T,
  );

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/MyStack;";

  @override
  MyStack<T> fromRef(jni.JObjectPtr ref) => MyStack.fromRef($T, ref);
}

extension $MyStackArray<T extends jni.JObject> on jni.JArray<MyStack<T>> {
  MyStack<T> operator [](int index) {
    return ($type.elementType as $MyStackType<T>)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, MyStack<T> value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}
