// Copyright (c) 2022, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

// Auto-generated initialization code.

final ffi.Pointer<T> Function<T extends ffi.NativeType>(String sym) jniLookup =
    ProtectedJniExtensions.initGeneratedLibrary("simple_package");

/// from: com.github.dart_lang.jnigen.simple_package.Example
class Example extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  Example.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ExampleType();

  /// from: static public final int ON
  static const ON = 1;

  /// from: static public final int OFF
  static const OFF = 0;

  static final _get_aux =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Example__aux")
          .asFunction<jni.JniResult Function()>();

  static final _set_aux = jniLookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>)>>("set_Example__aux")
      .asFunction<jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.simple_package.Example.Aux aux
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Example_Aux get aux =>
      const $Example_AuxType().fromRef(_get_aux().object);

  /// from: static public com.github.dart_lang.jnigen.simple_package.Example.Aux aux
  /// The returned object must be deleted after use, by calling the `delete` method.
  static set aux(Example_Aux value) => _set_aux(value.reference);

  static final _get_num =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Example__num")
          .asFunction<jni.JniResult Function()>();

  static final _set_num =
      jniLookup<ffi.NativeFunction<jni.JThrowablePtr Function(ffi.Int32)>>(
              "set_Example__num")
          .asFunction<jni.JThrowablePtr Function(int)>();

  /// from: static public int num
  static int get num => _get_num().integer;

  /// from: static public int num
  static set num(int value) => _set_num(value);

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Example() : super.fromRef(_ctor().object);

  static final _ctor1 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "Example__ctor1")
          .asFunction<jni.JniResult Function(int)>();

  /// from: public void <init>(int internal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Example.ctor1(
    int internal,
  ) : super.fromRef(_ctor1(internal).object);

  static final _whichExample = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__whichExample")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int whichExample()
  int whichExample() {
    return _whichExample(reference).integer;
  }

  static final _getAux =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example__getAux")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.github.dart_lang.jnigen.simple_package.Example.Aux getAux()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Example_Aux getAux() {
    return const $Example_AuxType().fromRef(_getAux().object);
  }

  static final _addInts = jniLookup<
              ffi.NativeFunction<jni.JniResult Function(ffi.Int32, ffi.Int32)>>(
          "Example__addInts")
      .asFunction<jni.JniResult Function(int, int)>();

  /// from: static public int addInts(int a, int b)
  static int addInts(
    int a,
    int b,
  ) {
    return _addInts(a, b).integer;
  }

  static final _getArr =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example__getArr")
          .asFunction<jni.JniResult Function()>();

  /// from: static public int[] getArr()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<jni.JInt> getArr() {
    return const jni.JArrayType(jni.JIntType()).fromRef(_getArr().object);
  }

  static final _addAll = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Example__addAll")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public int addAll(int[] arr)
  static int addAll(
    jni.JArray<jni.JInt> arr,
  ) {
    return _addAll(arr.reference).integer;
  }

  static final _getSelf = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__getSelf")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.simple_package.Example getSelf()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Example getSelf() {
    return const $ExampleType().fromRef(_getSelf(reference).object);
  }

  static final _getNum = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Example__getNum")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getNum()
  int getNum() {
    return _getNum(reference).integer;
  }

  static final _setNum = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Example__setNum")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setNum(int num)
  void setNum(
    int num,
  ) {
    return _setNum(reference, num).check();
  }

  static final _getInternal = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example__getInternal")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getInternal()
  int getInternal() {
    return _getInternal(reference).integer;
  }

  static final _setInternal = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Example__setInternal")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setInternal(int internal)
  void setInternal(
    int internal,
  ) {
    return _setInternal(reference, internal).check();
  }

  static final _throwException =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Example__throwException")
          .asFunction<jni.JniResult Function()>();

  /// from: static public void throwException()
  static void throwException() {
    return _throwException().check();
  }
}

class $ExampleType extends jni.JObjType<Example> {
  const $ExampleType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Example;";

  @override
  Example fromRef(jni.JObjectPtr ref) => Example.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.simple_package.Example$Aux
class Example_Aux extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  Example_Aux.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Example_AuxType();
  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_Example_Aux__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  jni.JObjectPtr, ffi.Uint8)>>("set_Example_Aux__value")
      .asFunction<jni.JThrowablePtr Function(jni.JObjectPtr, int)>();

  /// from: public boolean value
  bool get value => _get_value(reference).boolean;

  /// from: public boolean value
  set value(bool value) => _set_value(reference, value ? 1 : 0);

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Uint8)>>(
              "Example_Aux__ctor")
          .asFunction<jni.JniResult Function(int)>();

  /// from: public void <init>(boolean value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Example_Aux(
    bool value,
  ) : super.fromRef(_ctor(value ? 1 : 0).object);

  static final _getValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example_Aux__getValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getValue()
  bool getValue() {
    return _getValue(reference).boolean;
  }

  static final _setValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Example_Aux__setValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setValue(boolean value)
  void setValue(
    bool value,
  ) {
    return _setValue(reference, value ? 1 : 0).check();
  }
}

class $Example_AuxType extends jni.JObjType<Example_Aux> {
  const $Example_AuxType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/simple_package/Example$Aux;";

  @override
  Example_Aux fromRef(jni.JObjectPtr ref) => Example_Aux.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.pkg2.C2
class C2 extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  C2.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $C2Type();
  static final _get_CONSTANT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_C2__CONSTANT")
          .asFunction<jni.JniResult Function()>();

  static final _set_CONSTANT =
      jniLookup<ffi.NativeFunction<jni.JThrowablePtr Function(ffi.Int32)>>(
              "set_C2__CONSTANT")
          .asFunction<jni.JThrowablePtr Function(int)>();

  /// from: static public int CONSTANT
  static int get CONSTANT => _get_CONSTANT().integer;

  /// from: static public int CONSTANT
  static set CONSTANT(int value) => _set_CONSTANT(value);

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("C2__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  C2() : super.fromRef(_ctor().object);
}

class $C2Type extends jni.JObjType<C2> {
  const $C2Type();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/pkg2/C2;";

  @override
  C2 fromRef(jni.JObjectPtr ref) => C2.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.pkg2.Example
class Example1 extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  Example1.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Example1Type();
  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Example1__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Example1() : super.fromRef(_ctor().object);

  static final _whichExample = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Example1__whichExample")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int whichExample()
  int whichExample() {
    return _whichExample(reference).integer;
  }
}

class $Example1Type extends jni.JObjType<Example1> {
  const $Example1Type();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/pkg2/Example;";

  @override
  Example1 fromRef(jni.JObjectPtr ref) => Example1.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent
class GrandParent<$T extends jni.JObject> extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type(T);

  final jni.JObjType<$T> T;

  GrandParent.fromRef(
    this.T,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $GrandParentType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $GrandParentType(
      T,
    );
  }

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_GrandParent__value")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public T value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $T get value => T.fromRef(_get_value(reference).object);

  /// from: public T value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($T value) => _set_value(reference, value.reference);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("GrandParent__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(T value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GrandParent(
    $T value, {
    required this.T,
  }) : super.fromRef(_ctor(value.reference).object);

  static final _stringParent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("GrandParent__stringParent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.generics.GrandParent<T>.Parent<java.lang.String> stringParent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  GrandParent_Parent<jni.JObject, jni.JString> stringParent() {
    return const $GrandParent_ParentType(jni.JObjectType(), jni.JStringType())
        .fromRef(_stringParent(reference).object);
  }

  static final _varParent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("GrandParent__varParent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.generics.GrandParent<T>.Parent<S> varParent(S nestedValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GrandParent_Parent<jni.JObject, $S> varParent<$S extends jni.JObject>(
    $S nestedValue, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.commonType([
      nestedValue.$type,
    ]) as jni.JObjType<$S>;
    return $GrandParent_ParentType(const jni.JObjectType(), S)
        .fromRef(_varParent(reference, nestedValue.reference).object);
  }

  static final _stringStaticParent =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "GrandParent__stringStaticParent")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<java.lang.String> stringStaticParent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static GrandParent_StaticParent<jni.JString> stringStaticParent() {
    return const $GrandParent_StaticParentType(jni.JStringType())
        .fromRef(_stringStaticParent().object);
  }

  static final _varStaticParent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("GrandParent__varStaticParent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<S> varStaticParent(S value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static GrandParent_StaticParent<$S> varStaticParent<$S extends jni.JObject>(
    $S value, {
    jni.JObjType<$S>? S,
  }) {
    S ??= jni.commonType([
      value.$type,
    ]) as jni.JObjType<$S>;
    return $GrandParent_StaticParentType(S)
        .fromRef(_varStaticParent(value.reference).object);
  }

  static final _staticParentWithSameType = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "GrandParent__staticParentWithSameType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.generics.GrandParent.StaticParent<T> staticParentWithSameType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  GrandParent_StaticParent<$T> staticParentWithSameType() {
    return $GrandParent_StaticParentType(T)
        .fromRef(_staticParentWithSameType(reference).object);
  }
}

class $GrandParentType<$T extends jni.JObject>
    extends jni.JObjType<GrandParent<$T>> {
  final jni.JObjType<$T> T;

  const $GrandParentType(
    this.T,
  );

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/GrandParent;";

  @override
  GrandParent<$T> fromRef(jni.JObjectPtr ref) => GrandParent.fromRef(T, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$Parent
class GrandParent_Parent<$T extends jni.JObject, $S extends jni.JObject>
    extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type(T, S);

  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;

  GrandParent_Parent.fromRef(
    this.T,
    this.S,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $GrandParent_ParentType<$T, $S>
      type<$T extends jni.JObject, $S extends jni.JObject>(
    jni.JObjType<$T> T,
    jni.JObjType<$S> S,
  ) {
    return $GrandParent_ParentType(
      T,
      S,
    );
  }

  static final _get_parentValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_Parent__parentValue")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_parentValue = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_Parent__parentValue")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public T parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  $T get parentValue => T.fromRef(_get_parentValue(reference).object);

  /// from: public T parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  set parentValue($T value) => _set_parentValue(reference, value.reference);

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_Parent__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_GrandParent_Parent__value")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public S value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $S get value => S.fromRef(_get_value(reference).object);

  /// from: public S value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($S value) => _set_value(reference, value.reference);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("GrandParent_Parent__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(T parentValue, S value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GrandParent_Parent(
    $T parentValue,
    $S value, {
    required this.T,
    required this.S,
  }) : super.fromRef(_ctor(parentValue.reference, value.reference).object);
}

class $GrandParent_ParentType<$T extends jni.JObject, $S extends jni.JObject>
    extends jni.JObjType<GrandParent_Parent<$T, $S>> {
  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;

  const $GrandParent_ParentType(
    this.T,
    this.S,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent;";

  @override
  GrandParent_Parent<$T, $S> fromRef(jni.JObjectPtr ref) =>
      GrandParent_Parent.fromRef(T, S, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$Parent$Child
class GrandParent_Parent_Child<$T extends jni.JObject, $S extends jni.JObject,
    $U extends jni.JObject> extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type(T, S, U);

  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  GrandParent_Parent_Child.fromRef(
    this.T,
    this.S,
    this.U,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $GrandParent_Parent_ChildType<$T, $S, $U> type<$T extends jni.JObject,
      $S extends jni.JObject, $U extends jni.JObject>(
    jni.JObjType<$T> T,
    jni.JObjType<$S> S,
    jni.JObjType<$U> U,
  ) {
    return $GrandParent_Parent_ChildType(
      T,
      S,
      U,
    );
  }

  static final _get_grandParentValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_Parent_Child__grandParentValue")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_grandParentValue = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_Parent_Child__grandParentValue")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public T grandParentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  $T get grandParentValue => T.fromRef(_get_grandParentValue(reference).object);

  /// from: public T grandParentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  set grandParentValue($T value) =>
      _set_grandParentValue(reference, value.reference);

  static final _get_parentValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_Parent_Child__parentValue")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_parentValue = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_Parent_Child__parentValue")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public S parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  $S get parentValue => S.fromRef(_get_parentValue(reference).object);

  /// from: public S parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  set parentValue($S value) => _set_parentValue(reference, value.reference);

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_Parent_Child__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_Parent_Child__value")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public U value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $U get value => U.fromRef(_get_value(reference).object);

  /// from: public U value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($U value) => _set_value(reference, value.reference);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("GrandParent_Parent_Child__ctor")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(T grandParentValue, S parentValue, U value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GrandParent_Parent_Child(
    $T grandParentValue,
    $S parentValue,
    $U value, {
    required this.T,
    required this.S,
    required this.U,
  }) : super.fromRef(_ctor(grandParentValue.reference, parentValue.reference,
                value.reference)
            .object);
}

class $GrandParent_Parent_ChildType<$T extends jni.JObject,
        $S extends jni.JObject, $U extends jni.JObject>
    extends jni.JObjType<GrandParent_Parent_Child<$T, $S, $U>> {
  final jni.JObjType<$T> T;
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  const $GrandParent_Parent_ChildType(
    this.T,
    this.S,
    this.U,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$Parent$Child;";

  @override
  GrandParent_Parent_Child<$T, $S, $U> fromRef(jni.JObjectPtr ref) =>
      GrandParent_Parent_Child.fromRef(T, S, U, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$StaticParent
class GrandParent_StaticParent<$S extends jni.JObject> extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type(S);

  final jni.JObjType<$S> S;

  GrandParent_StaticParent.fromRef(
    this.S,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParentType<$S> type<$S extends jni.JObject>(
    jni.JObjType<$S> S,
  ) {
    return $GrandParent_StaticParentType(
      S,
    );
  }

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_StaticParent__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_StaticParent__value")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public S value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $S get value => S.fromRef(_get_value(reference).object);

  /// from: public S value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($S value) => _set_value(reference, value.reference);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("GrandParent_StaticParent__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(S value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GrandParent_StaticParent(
    $S value, {
    required this.S,
  }) : super.fromRef(_ctor(value.reference).object);
}

class $GrandParent_StaticParentType<$S extends jni.JObject>
    extends jni.JObjType<GrandParent_StaticParent<$S>> {
  final jni.JObjType<$S> S;

  const $GrandParent_StaticParentType(
    this.S,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent;";

  @override
  GrandParent_StaticParent<$S> fromRef(jni.JObjectPtr ref) =>
      GrandParent_StaticParent.fromRef(S, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.generics.GrandParent$StaticParent$Child
class GrandParent_StaticParent_Child<$S extends jni.JObject,
    $U extends jni.JObject> extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type(S, U);

  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  GrandParent_StaticParent_Child.fromRef(
    this.S,
    this.U,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $GrandParent_StaticParent_ChildType<$S, $U>
      type<$S extends jni.JObject, $U extends jni.JObject>(
    jni.JObjType<$S> S,
    jni.JObjType<$U> U,
  ) {
    return $GrandParent_StaticParent_ChildType(
      S,
      U,
    );
  }

  static final _get_parentValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_StaticParent_Child__parentValue")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_parentValue = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_StaticParent_Child__parentValue")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public S parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  $S get parentValue => S.fromRef(_get_parentValue(reference).object);

  /// from: public S parentValue
  /// The returned object must be deleted after use, by calling the `delete` method.
  set parentValue($S value) => _set_parentValue(reference, value.reference);

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_GrandParent_StaticParent_Child__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_GrandParent_StaticParent_Child__value")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public U value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $U get value => U.fromRef(_get_value(reference).object);

  /// from: public U value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($U value) => _set_value(reference, value.reference);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "GrandParent_StaticParent_Child__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(S parentValue, U value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  GrandParent_StaticParent_Child(
    $S parentValue,
    $U value, {
    required this.S,
    required this.U,
  }) : super.fromRef(_ctor(parentValue.reference, value.reference).object);
}

class $GrandParent_StaticParent_ChildType<$S extends jni.JObject,
        $U extends jni.JObject>
    extends jni.JObjType<GrandParent_StaticParent_Child<$S, $U>> {
  final jni.JObjType<$S> S;
  final jni.JObjType<$U> U;

  const $GrandParent_StaticParent_ChildType(
    this.S,
    this.U,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/GrandParent$StaticParent$Child;";

  @override
  GrandParent_StaticParent_Child<$S, $U> fromRef(jni.JObjectPtr ref) =>
      GrandParent_StaticParent_Child.fromRef(S, U, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.generics.MyMap
class MyMap<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type(K, V);

  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  MyMap.fromRef(
    this.K,
    this.V,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $MyMapType<$K, $V>
      type<$K extends jni.JObject, $V extends jni.JObject>(
    jni.JObjType<$K> K,
    jni.JObjType<$V> V,
  ) {
    return $MyMapType(
      K,
      V,
    );
  }

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("MyMap__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MyMap({
    required this.K,
    required this.V,
  }) : super.fromRef(_ctor().object);

  static final _get0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("MyMap__get0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public V get(K key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  $V get0(
    $K key,
  ) {
    return V.fromRef(_get0(reference, key.reference).object);
  }

  static final _put = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("MyMap__put")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public V put(K key, V value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  $V put(
    $K key,
    $V value,
  ) {
    return V.fromRef(_put(reference, key.reference, value.reference).object);
  }

  static final _entryStack = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("MyMap__entryStack")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.github.dart_lang.jnigen.generics.MyStack<com.github.dart_lang.jnigen.generics.MyMap<K,V>.MyEntry> entryStack()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MyStack<MyMap_MyEntry<jni.JObject, jni.JObject>> entryStack() {
    return const $MyStackType(
            $MyMap_MyEntryType(jni.JObjectType(), jni.JObjectType()))
        .fromRef(_entryStack(reference).object);
  }
}

class $MyMapType<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObjType<MyMap<$K, $V>> {
  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  const $MyMapType(
    this.K,
    this.V,
  );

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/MyMap;";

  @override
  MyMap<$K, $V> fromRef(jni.JObjectPtr ref) => MyMap.fromRef(K, V, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.generics.MyMap$MyEntry
class MyMap_MyEntry<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type(K, V);

  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  MyMap_MyEntry.fromRef(
    this.K,
    this.V,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $MyMap_MyEntryType<$K, $V>
      type<$K extends jni.JObject, $V extends jni.JObject>(
    jni.JObjType<$K> K,
    jni.JObjType<$V> V,
  ) {
    return $MyMap_MyEntryType(
      K,
      V,
    );
  }

  static final _get_key = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_MyMap_MyEntry__key")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_key = jniLookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_MyMap_MyEntry__key")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public K key
  /// The returned object must be deleted after use, by calling the `delete` method.
  $K get key => K.fromRef(_get_key(reference).object);

  /// from: public K key
  /// The returned object must be deleted after use, by calling the `delete` method.
  set key($K value) => _set_key(reference, value.reference);

  static final _get_value = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObjectPtr,
  )>>("get_MyMap_MyEntry__value")
      .asFunction<
          jni.JniResult Function(
    jni.JObjectPtr,
  )>();

  static final _set_value = jniLookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(jni.JObjectPtr,
                  ffi.Pointer<ffi.Void>)>>("set_MyMap_MyEntry__value")
      .asFunction<
          jni.JThrowablePtr Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public V value
  /// The returned object must be deleted after use, by calling the `delete` method.
  $V get value => V.fromRef(_get_value(reference).object);

  /// from: public V value
  /// The returned object must be deleted after use, by calling the `delete` method.
  set value($V value) => _set_value(reference, value.reference);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MyMap_MyEntry__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(K key, V value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  MyMap_MyEntry(
    $K key,
    $V value, {
    required this.K,
    required this.V,
  }) : super.fromRef(_ctor(key.reference, value.reference).object);
}

class $MyMap_MyEntryType<$K extends jni.JObject, $V extends jni.JObject>
    extends jni.JObjType<MyMap_MyEntry<$K, $V>> {
  final jni.JObjType<$K> K;
  final jni.JObjType<$V> V;

  const $MyMap_MyEntryType(
    this.K,
    this.V,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/MyMap$MyEntry;";

  @override
  MyMap_MyEntry<$K, $V> fromRef(jni.JObjectPtr ref) =>
      MyMap_MyEntry.fromRef(K, V, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.generics.MyStack
class MyStack<$T extends jni.JObject> extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type(T);

  final jni.JObjType<$T> T;

  MyStack.fromRef(
    this.T,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $MyStackType<$T> type<$T extends jni.JObject>(
    jni.JObjType<$T> T,
  ) {
    return $MyStackType(
      T,
    );
  }

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("MyStack__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MyStack({
    required this.T,
  }) : super.fromRef(_ctor().object);

  static final _of =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("MyStack__of")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<T> of()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static MyStack<$T> of<$T extends jni.JObject>({
    required jni.JObjType<$T> T,
  }) {
    return $MyStackType(T).fromRef(_of().object);
  }

  static final _of1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("MyStack__of1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T obj)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static MyStack<$T> of1<$T extends jni.JObject>(
    $T obj, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.commonType([
      obj.$type,
    ]) as jni.JObjType<$T>;
    return $MyStackType(T).fromRef(_of1(obj.reference).object);
  }

  static final _of2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MyStack__of2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.generics.MyStack<T> of(T obj, T obj2)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static MyStack<$T> of2<$T extends jni.JObject>(
    $T obj,
    $T obj2, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.commonType([
      obj2.$type,
      obj.$type,
    ]) as jni.JObjType<$T>;
    return $MyStackType(T).fromRef(_of2(obj.reference, obj2.reference).object);
  }

  static final _push = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MyStack__push")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void push(T item)
  void push(
    $T item,
  ) {
    return _push(reference, item.reference).check();
  }

  static final _pop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("MyStack__pop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public T pop()
  /// The returned object must be deleted after use, by calling the `delete` method.
  $T pop() {
    return T.fromRef(_pop(reference).object);
  }
}

class $MyStackType<$T extends jni.JObject> extends jni.JObjType<MyStack<$T>> {
  final jni.JObjType<$T> T;

  const $MyStackType(
    this.T,
  );

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/MyStack;";

  @override
  MyStack<$T> fromRef(jni.JObjectPtr ref) => MyStack.fromRef(T, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.generics.StringKeyedMap
class StringKeyedMap<$V extends jni.JObject> extends MyMap<jni.JString, $V> {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type(V);

  final jni.JObjType<$V> V;

  StringKeyedMap.fromRef(
    this.V,
    jni.JObjectPtr ref,
  ) : super.fromRef(const jni.JStringType(), V, ref);

  /// The type which includes information such as the signature of this class.
  static $StringKeyedMapType<$V> type<$V extends jni.JObject>(
    jni.JObjType<$V> V,
  ) {
    return $StringKeyedMapType(
      V,
    );
  }

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "StringKeyedMap__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  StringKeyedMap({
    required this.V,
  }) : super.fromRef(const jni.JStringType(), V, _ctor().object);
}

class $StringKeyedMapType<$V extends jni.JObject>
    extends jni.JObjType<StringKeyedMap<$V>> {
  final jni.JObjType<$V> V;

  const $StringKeyedMapType(
    this.V,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/StringKeyedMap;";

  @override
  StringKeyedMap<$V> fromRef(jni.JObjectPtr ref) =>
      StringKeyedMap.fromRef(V, ref);

  @override
  jni.JObjType get superType => $MyMapType(const jni.JStringType(), V);

  @override
  final superCount = 2;
}

/// from: com.github.dart_lang.jnigen.generics.StringMap
class StringMap extends StringKeyedMap<jni.JString> {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  StringMap.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(const jni.JStringType(), ref);

  /// The type which includes information such as the signature of this class.
  static const type = $StringMapType();
  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("StringMap__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  StringMap() : super.fromRef(const jni.JStringType(), _ctor().object);
}

class $StringMapType extends jni.JObjType<StringMap> {
  const $StringMapType();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/StringMap;";

  @override
  StringMap fromRef(jni.JObjectPtr ref) => StringMap.fromRef(ref);

  @override
  jni.JObjType get superType => const $StringKeyedMapType(jni.JStringType());

  @override
  final superCount = 3;
}

/// from: com.github.dart_lang.jnigen.generics.StringStack
class StringStack extends MyStack<jni.JString> {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  StringStack.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(const jni.JStringType(), ref);

  /// The type which includes information such as the signature of this class.
  static const type = $StringStackType();
  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "StringStack__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  StringStack() : super.fromRef(const jni.JStringType(), _ctor().object);
}

class $StringStackType extends jni.JObjType<StringStack> {
  const $StringStackType();

  @override
  String get signature => r"Lcom/github/dart_lang/jnigen/generics/StringStack;";

  @override
  StringStack fromRef(jni.JObjectPtr ref) => StringStack.fromRef(ref);

  @override
  jni.JObjType get superType => const $MyStackType(jni.JStringType());

  @override
  final superCount = 2;
}

/// from: com.github.dart_lang.jnigen.generics.StringValuedMap
class StringValuedMap<$K extends jni.JObject> extends MyMap<$K, jni.JString> {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type(K);

  final jni.JObjType<$K> K;

  StringValuedMap.fromRef(
    this.K,
    jni.JObjectPtr ref,
  ) : super.fromRef(K, const jni.JStringType(), ref);

  /// The type which includes information such as the signature of this class.
  static $StringValuedMapType<$K> type<$K extends jni.JObject>(
    jni.JObjType<$K> K,
  ) {
    return $StringValuedMapType(
      K,
    );
  }

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "StringValuedMap__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  StringValuedMap({
    required this.K,
  }) : super.fromRef(K, const jni.JStringType(), _ctor().object);
}

class $StringValuedMapType<$K extends jni.JObject>
    extends jni.JObjType<StringValuedMap<$K>> {
  final jni.JObjType<$K> K;

  const $StringValuedMapType(
    this.K,
  );

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/generics/StringValuedMap;";

  @override
  StringValuedMap<$K> fromRef(jni.JObjectPtr ref) =>
      StringValuedMap.fromRef(K, ref);

  @override
  jni.JObjType get superType => $MyMapType(K, const jni.JStringType());

  @override
  final superCount = 2;
}

/// from: com.github.dart_lang.jnigen.annotations.JsonSerializable$Case
class JsonSerializable_Case extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  JsonSerializable_Case.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $JsonSerializable_CaseType();
  static final _values =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "JsonSerializable_Case__values")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.github.dart_lang.jnigen.annotations.JsonSerializable.Case[] values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<JsonSerializable_Case> values() {
    return const jni.JArrayType($JsonSerializable_CaseType())
        .fromRef(_values().object);
  }

  static final _valueOf = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("JsonSerializable_Case__valueOf")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.github.dart_lang.jnigen.annotations.JsonSerializable.Case valueOf(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static JsonSerializable_Case valueOf(
    jni.JString name,
  ) {
    return const $JsonSerializable_CaseType()
        .fromRef(_valueOf(name.reference).object);
  }
}

class $JsonSerializable_CaseType extends jni.JObjType<JsonSerializable_Case> {
  const $JsonSerializable_CaseType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/annotations/JsonSerializable$Case;";

  @override
  JsonSerializable_Case fromRef(jni.JObjectPtr ref) =>
      JsonSerializable_Case.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}

/// from: com.github.dart_lang.jnigen.annotations.MyDataClass
class MyDataClass extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  MyDataClass.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $MyDataClassType();
  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "MyDataClass__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  MyDataClass() : super.fromRef(_ctor().object);
}

class $MyDataClassType extends jni.JObjType<MyDataClass> {
  const $MyDataClassType();

  @override
  String get signature =>
      r"Lcom/github/dart_lang/jnigen/annotations/MyDataClass;";

  @override
  MyDataClass fromRef(jni.JObjectPtr ref) => MyDataClass.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;
}
