// Copyright (c) 2022, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:io' as io;
import 'package:path/path.dart';

const _license = '''
// Copyright (c) 2022, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

''';
final targetTypes = {
  "String": "String",
  "Object": "JniObject",
  "Boolean": "bool",
  "Byte": "int",
  "Char": "int",
  "Short": "int",
  "Int": "int",
  "Long": "int",
  "Float": "double",
  "Double": "double",
  "Void": "void"
};

final resultConverters = {
  "String": (String resultVar) => "return strRes",
  "Object": (String resultVar) =>
      "return JniObject.of(_env, $resultVar, nullptr)",
  "Boolean": (String resultVar) => "return $resultVar != 0",
};

final invokeResultConverters = {
  "String": (String resultVar) => "return strRes",
  "Object": (String resultVar) =>
      "return JniObject.of(env, $resultVar, nullptr)",
  "Boolean": (String resultVar) => "return $resultVar != 0",
};

void main(List<String> args) {
  final script = io.Platform.script;
  final scriptDir = dirname(script.toFilePath(windows: io.Platform.isWindows));
  String getTemplate(String name) {
    return io.File(join(scriptDir, 'templates', name)).readAsStringSync();
  }

  final methodTemplates = getTemplate('jni_object_methods.dart.tmpl');
  final fieldTemplates = getTemplate('jni_object_fields.dart.tmpl');
  final invokeTemplates = getTemplate('invoke_static_methods.dart.tmpl');
  final retrieveTemplates = getTemplate('retrieve_static_fields.dart.tmpl');

  final outputDir = join("lib", "src");
  final sInst = StringBuffer();
  final sStatic = StringBuffer();
  final sInvoke = StringBuffer();
  final outPutPaths = {
    sInst: join(outputDir, "jni_object_methods_generated.dart"),
    sStatic: join(outputDir, "jni_class_methods_generated.dart"),
    sInvoke: join(outputDir, "direct_methods_generated.dart")
  };
  for (final s in [sInst, sStatic, sInvoke]) {
    s.write(_license);
    s.write("// Autogenerated; DO NOT EDIT\n"
        "// Generated by running the script in tool/gen_aux_methods.dart\n");
    s.write("// coverage:ignore-file\n");
  }

  sInst.write("part of 'jni_object.dart';\n\n");
  sStatic.write("part of 'jni_class.dart';\n\n");
  sInvoke.write("part of 'jni.dart';\n\n");

  sInst.write("extension JniObjectCallMethods on JniObject {");
  sStatic.write("extension JniClassCallMethods on JniClass {");
  sInvoke.write("extension JniInvokeMethods on Jni {");

  for (final t in targetTypes.keys) {
    void write(String template) {
      final resultConverter =
          resultConverters[t] ?? (resultVar) => "return $resultVar";
      final skel = template
          .replaceAll("{TYPE}", t == "String" ? "Object" : t)
          .replaceAll("{PTYPE}", t)
          .replaceAll("{TARGET_TYPE}", targetTypes[t]!)
          .replaceAll("{RESULT}", resultConverter("result"))
          .replaceAll(
              "{STR_REF_DEL}",
              t == "String"
                  ? "final strRes = _env.asDartString(result, "
                      "deleteOriginal: true);"
                  : "");
      final inst_ =
          skel.replaceAll("{STATIC}", "").replaceAll("{THIS}", "_obj");
      final static_ =
          skel.replaceAll("{STATIC}", "Static").replaceAll("{THIS}", "_cls");
      sInst.write(inst_);
      sStatic.write(static_);
    }

    write(methodTemplates);
    if (t != "Void") {
      write(fieldTemplates);
    }
    final invokeResultConverter =
        (invokeResultConverters[t] ?? (String r) => "return $r");
    void writeI(String template) {
      final replaced = template
          .replaceAll("{TYPE}", t == "String" ? "Object" : t)
          .replaceAll("{PTYPE}", t)
          .replaceAll("{TARGET_TYPE}", targetTypes[t]!)
          .replaceAll("{CLS_REF_DEL}",
              t == "Object" || t == "String" ? "" : "env.DeleteLocalRef(cls);")
          .replaceAll(
              "{STR_REF_DEL}",
              t == "String"
                  ? "final strRes = env.asDartString(result, "
                      "deleteOriginal: true);"
                  : "")
          .replaceAll("{INVOKE_RESULT}", invokeResultConverter("result"));
      sInvoke.write(replaced);
    }

    writeI(invokeTemplates);
    if (t != "Void") {
      writeI(retrieveTemplates);
    }
  }
  sInst.write("}");
  sStatic.write("}");
  sInvoke.write("}");
  for (final s in [sInst, sStatic, sInvoke]) {
    final outputFile = io.File(outPutPaths[s]!);
    outputFile.writeAsStringSync(s.toString(), flush: true);
  }
  io.stderr.write("Running dart format..\n");
  io.Process.run("dart", ["format", ...outPutPaths.values]);
}
